# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
from . import _meep
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _meep.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _meep.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _meep.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _meep.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _meep.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _meep.SwigPyIterator_equal(self, x)

    def copy(self):
        return _meep.SwigPyIterator_copy(self)

    def next(self):
        return _meep.SwigPyIterator_next(self)

    def __next__(self):
        return _meep.SwigPyIterator___next__(self)

    def previous(self):
        return _meep.SwigPyIterator_previous(self)

    def advance(self, n):
        return _meep.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _meep.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _meep.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _meep.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _meep.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _meep.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _meep.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _meep.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

py_pml_profile = _meep.py_pml_profile

def py_do_harminv(vals, dt, f_min, f_max, maxbands, spectral_density, Q_thresh, rel_err_thresh, err_thresh, rel_amp_thresh, amp_thresh):
    return _meep.py_do_harminv(vals, dt, f_min, f_max, maxbands, spectral_density, Q_thresh, rel_err_thresh, err_thresh, rel_amp_thresh, amp_thresh)
py_do_harminv = _meep.py_do_harminv

def _get_farfield(f, v):
    return _meep._get_farfield(f, v)
_get_farfield = _meep._get_farfield

def _dft_ldos_ldos(f):
    return _meep._dft_ldos_ldos(f)
_dft_ldos_ldos = _meep._dft_ldos_ldos

def _dft_ldos_F(f):
    return _meep._dft_ldos_F(f)
_dft_ldos_F = _meep._dft_ldos_F

def _dft_ldos_J(f):
    return _meep._dft_ldos_J(f)
_dft_ldos_J = _meep._dft_ldos_J

def _get_dft_data_size(dc):
    return _meep._get_dft_data_size(dc)
_get_dft_data_size = _meep._get_dft_data_size

def _get_dft_data(dc, cdata):
    return _meep._get_dft_data(dc, cdata)
_get_dft_data = _meep._get_dft_data

def _load_dft_data(dc, cdata):
    return _meep._load_dft_data(dc, cdata)
_load_dft_data = _meep._load_dft_data

def make_volume_list(v, c, weight, next):
    return _meep.make_volume_list(v, c, weight, next)
make_volume_list = _meep.make_volume_list

def get_dft_flux_array(f, dft, c, num_freq):
    return _meep.get_dft_flux_array(f, dft, c, num_freq)
get_dft_flux_array = _meep.get_dft_flux_array

def get_dft_fields_array(f, dft, c, num_freq):
    return _meep.get_dft_fields_array(f, dft, c, num_freq)
get_dft_fields_array = _meep.get_dft_fields_array

def get_dft_force_array(f, dft, c, num_freq):
    return _meep.get_dft_force_array(f, dft, c, num_freq)
get_dft_force_array = _meep.get_dft_force_array

def get_dft_near2far_array(f, dft, c, num_freq):
    return _meep.get_dft_near2far_array(f, dft, c, num_freq)
get_dft_near2far_array = _meep.get_dft_near2far_array
class FragmentStatsVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FragmentStatsVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FragmentStatsVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.FragmentStatsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.FragmentStatsVector___nonzero__(self)

    def __bool__(self):
        return _meep.FragmentStatsVector___bool__(self)

    def __len__(self):
        return _meep.FragmentStatsVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.FragmentStatsVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.FragmentStatsVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.FragmentStatsVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.FragmentStatsVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.FragmentStatsVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.FragmentStatsVector___setitem__(self, *args)

    def pop(self):
        return _meep.FragmentStatsVector_pop(self)

    def append(self, x):
        return _meep.FragmentStatsVector_append(self, x)

    def empty(self):
        return _meep.FragmentStatsVector_empty(self)

    def size(self):
        return _meep.FragmentStatsVector_size(self)

    def swap(self, v):
        return _meep.FragmentStatsVector_swap(self, v)

    def begin(self):
        return _meep.FragmentStatsVector_begin(self)

    def end(self):
        return _meep.FragmentStatsVector_end(self)

    def rbegin(self):
        return _meep.FragmentStatsVector_rbegin(self)

    def rend(self):
        return _meep.FragmentStatsVector_rend(self)

    def clear(self):
        return _meep.FragmentStatsVector_clear(self)

    def get_allocator(self):
        return _meep.FragmentStatsVector_get_allocator(self)

    def pop_back(self):
        return _meep.FragmentStatsVector_pop_back(self)

    def erase(self, *args):
        return _meep.FragmentStatsVector_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_FragmentStatsVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.FragmentStatsVector_push_back(self, x)

    def front(self):
        return _meep.FragmentStatsVector_front(self)

    def back(self):
        return _meep.FragmentStatsVector_back(self)

    def assign(self, n, x):
        return _meep.FragmentStatsVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.FragmentStatsVector_resize(self, *args)

    def insert(self, *args):
        return _meep.FragmentStatsVector_insert(self, *args)

    def reserve(self, n):
        return _meep.FragmentStatsVector_reserve(self, n)

    def capacity(self):
        return _meep.FragmentStatsVector_capacity(self)
    __swig_destroy__ = _meep.delete_FragmentStatsVector
    __del__ = lambda self: None
FragmentStatsVector_swigregister = _meep.FragmentStatsVector_swigregister
FragmentStatsVector_swigregister(FragmentStatsVector)

class DftDataVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DftDataVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DftDataVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.DftDataVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.DftDataVector___nonzero__(self)

    def __bool__(self):
        return _meep.DftDataVector___bool__(self)

    def __len__(self):
        return _meep.DftDataVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.DftDataVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.DftDataVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.DftDataVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.DftDataVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.DftDataVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.DftDataVector___setitem__(self, *args)

    def pop(self):
        return _meep.DftDataVector_pop(self)

    def append(self, x):
        return _meep.DftDataVector_append(self, x)

    def empty(self):
        return _meep.DftDataVector_empty(self)

    def size(self):
        return _meep.DftDataVector_size(self)

    def swap(self, v):
        return _meep.DftDataVector_swap(self, v)

    def begin(self):
        return _meep.DftDataVector_begin(self)

    def end(self):
        return _meep.DftDataVector_end(self)

    def rbegin(self):
        return _meep.DftDataVector_rbegin(self)

    def rend(self):
        return _meep.DftDataVector_rend(self)

    def clear(self):
        return _meep.DftDataVector_clear(self)

    def get_allocator(self):
        return _meep.DftDataVector_get_allocator(self)

    def pop_back(self):
        return _meep.DftDataVector_pop_back(self)

    def erase(self, *args):
        return _meep.DftDataVector_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_DftDataVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.DftDataVector_push_back(self, x)

    def front(self):
        return _meep.DftDataVector_front(self)

    def back(self):
        return _meep.DftDataVector_back(self)

    def assign(self, n, x):
        return _meep.DftDataVector_assign(self, n, x)

    def insert(self, *args):
        return _meep.DftDataVector_insert(self, *args)

    def reserve(self, n):
        return _meep.DftDataVector_reserve(self, n)

    def capacity(self):
        return _meep.DftDataVector_capacity(self)
    __swig_destroy__ = _meep.delete_DftDataVector
    __del__ = lambda self: None
DftDataVector_swigregister = _meep.DftDataVector_swigregister
DftDataVector_swigregister(DftDataVector)

class VolumeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VolumeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VolumeVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.VolumeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.VolumeVector___nonzero__(self)

    def __bool__(self):
        return _meep.VolumeVector___bool__(self)

    def __len__(self):
        return _meep.VolumeVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.VolumeVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.VolumeVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.VolumeVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.VolumeVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.VolumeVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.VolumeVector___setitem__(self, *args)

    def pop(self):
        return _meep.VolumeVector_pop(self)

    def append(self, x):
        return _meep.VolumeVector_append(self, x)

    def empty(self):
        return _meep.VolumeVector_empty(self)

    def size(self):
        return _meep.VolumeVector_size(self)

    def swap(self, v):
        return _meep.VolumeVector_swap(self, v)

    def begin(self):
        return _meep.VolumeVector_begin(self)

    def end(self):
        return _meep.VolumeVector_end(self)

    def rbegin(self):
        return _meep.VolumeVector_rbegin(self)

    def rend(self):
        return _meep.VolumeVector_rend(self)

    def clear(self):
        return _meep.VolumeVector_clear(self)

    def get_allocator(self):
        return _meep.VolumeVector_get_allocator(self)

    def pop_back(self):
        return _meep.VolumeVector_pop_back(self)

    def erase(self, *args):
        return _meep.VolumeVector_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_VolumeVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.VolumeVector_push_back(self, x)

    def front(self):
        return _meep.VolumeVector_front(self)

    def back(self):
        return _meep.VolumeVector_back(self)

    def assign(self, n, x):
        return _meep.VolumeVector_assign(self, n, x)

    def insert(self, *args):
        return _meep.VolumeVector_insert(self, *args)

    def reserve(self, n):
        return _meep.VolumeVector_reserve(self, n)

    def capacity(self):
        return _meep.VolumeVector_capacity(self)
    __swig_destroy__ = _meep.delete_VolumeVector
    __del__ = lambda self: None
VolumeVector_swigregister = _meep.VolumeVector_swigregister
VolumeVector_swigregister(VolumeVector)

class IntVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.IntVector___nonzero__(self)

    def __bool__(self):
        return _meep.IntVector___bool__(self)

    def __len__(self):
        return _meep.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.IntVector___setitem__(self, *args)

    def pop(self):
        return _meep.IntVector_pop(self)

    def append(self, x):
        return _meep.IntVector_append(self, x)

    def empty(self):
        return _meep.IntVector_empty(self)

    def size(self):
        return _meep.IntVector_size(self)

    def swap(self, v):
        return _meep.IntVector_swap(self, v)

    def begin(self):
        return _meep.IntVector_begin(self)

    def end(self):
        return _meep.IntVector_end(self)

    def rbegin(self):
        return _meep.IntVector_rbegin(self)

    def rend(self):
        return _meep.IntVector_rend(self)

    def clear(self):
        return _meep.IntVector_clear(self)

    def get_allocator(self):
        return _meep.IntVector_get_allocator(self)

    def pop_back(self):
        return _meep.IntVector_pop_back(self)

    def erase(self, *args):
        return _meep.IntVector_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_IntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.IntVector_push_back(self, x)

    def front(self):
        return _meep.IntVector_front(self)

    def back(self):
        return _meep.IntVector_back(self)

    def assign(self, n, x):
        return _meep.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.IntVector_resize(self, *args)

    def insert(self, *args):
        return _meep.IntVector_insert(self, *args)

    def reserve(self, n):
        return _meep.IntVector_reserve(self, n)

    def capacity(self):
        return _meep.IntVector_capacity(self)
    __swig_destroy__ = _meep.delete_IntVector
    __del__ = lambda self: None
IntVector_swigregister = _meep.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _meep.DoubleVector___bool__(self)

    def __len__(self):
        return _meep.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _meep.DoubleVector_pop(self)

    def append(self, x):
        return _meep.DoubleVector_append(self, x)

    def empty(self):
        return _meep.DoubleVector_empty(self)

    def size(self):
        return _meep.DoubleVector_size(self)

    def swap(self, v):
        return _meep.DoubleVector_swap(self, v)

    def begin(self):
        return _meep.DoubleVector_begin(self)

    def end(self):
        return _meep.DoubleVector_end(self)

    def rbegin(self):
        return _meep.DoubleVector_rbegin(self)

    def rend(self):
        return _meep.DoubleVector_rend(self)

    def clear(self):
        return _meep.DoubleVector_clear(self)

    def get_allocator(self):
        return _meep.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _meep.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _meep.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.DoubleVector_push_back(self, x)

    def front(self):
        return _meep.DoubleVector_front(self)

    def back(self):
        return _meep.DoubleVector_back(self)

    def assign(self, n, x):
        return _meep.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _meep.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _meep.DoubleVector_reserve(self, n)

    def capacity(self):
        return _meep.DoubleVector_capacity(self)
    __swig_destroy__ = _meep.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _meep.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

Ex = _meep.Ex
Ey = _meep.Ey
Er = _meep.Er
Ep = _meep.Ep
Ez = _meep.Ez
Hx = _meep.Hx
Hy = _meep.Hy
Hr = _meep.Hr
Hp = _meep.Hp
Hz = _meep.Hz
Dx = _meep.Dx
Dy = _meep.Dy
Dr = _meep.Dr
Dp = _meep.Dp
Dz = _meep.Dz
Bx = _meep.Bx
By = _meep.By
Br = _meep.Br
Bp = _meep.Bp
Bz = _meep.Bz
Dielectric = _meep.Dielectric
Permeability = _meep.Permeability
Sx = _meep.Sx
Sy = _meep.Sy
Sr = _meep.Sr
Sp = _meep.Sp
Sz = _meep.Sz
EnergyDensity = _meep.EnergyDensity
D_EnergyDensity = _meep.D_EnergyDensity
H_EnergyDensity = _meep.H_EnergyDensity
D1 = _meep.D1
D2 = _meep.D2
D3 = _meep.D3
Dcyl = _meep.Dcyl
E_stuff = _meep.E_stuff
H_stuff = _meep.H_stuff
D_stuff = _meep.D_stuff
B_stuff = _meep.B_stuff
PE_stuff = _meep.PE_stuff
PH_stuff = _meep.PH_stuff
WE_stuff = _meep.WE_stuff
WH_stuff = _meep.WH_stuff
High = _meep.High
Low = _meep.Low
X = _meep.X
Y = _meep.Y
Z = _meep.Z
R = _meep.R
P = _meep.P
NO_DIRECTION = _meep.NO_DIRECTION
class signed_direction(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, signed_direction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, signed_direction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_signed_direction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __mul__(self, ph):
        return _meep.signed_direction___mul__(self, ph)

    def __eq__(self, sd):
        return _meep.signed_direction___eq__(self, sd)

    def __ne__(self, sd):
        return _meep.signed_direction___ne__(self, sd)
    __swig_setmethods__["d"] = _meep.signed_direction_d_set
    __swig_getmethods__["d"] = _meep.signed_direction_d_get
    if _newclass:
        d = _swig_property(_meep.signed_direction_d_get, _meep.signed_direction_d_set)
    __swig_setmethods__["flipped"] = _meep.signed_direction_flipped_set
    __swig_getmethods__["flipped"] = _meep.signed_direction_flipped_get
    if _newclass:
        flipped = _swig_property(_meep.signed_direction_flipped_get, _meep.signed_direction_flipped_set)
    __swig_setmethods__["phase"] = _meep.signed_direction_phase_set
    __swig_getmethods__["phase"] = _meep.signed_direction_phase_get
    if _newclass:
        phase = _swig_property(_meep.signed_direction_phase_get, _meep.signed_direction_phase_set)
    __swig_destroy__ = _meep.delete_signed_direction
    __del__ = lambda self: None
signed_direction_swigregister = _meep.signed_direction_swigregister
signed_direction_swigregister(signed_direction)
cvar = _meep.cvar
NUM_FIELD_COMPONENTS = cvar.NUM_FIELD_COMPONENTS
NUM_FIELD_TYPES = cvar.NUM_FIELD_TYPES


def number_of_directions(dim):
    return _meep.number_of_directions(dim)
number_of_directions = _meep.number_of_directions

def start_at_direction(dim):
    return _meep.start_at_direction(dim)
start_at_direction = _meep.start_at_direction

def stop_at_direction(dim):
    return _meep.stop_at_direction(dim)
stop_at_direction = _meep.stop_at_direction

def first_field_component(ft):
    return _meep.first_field_component(ft)
first_field_component = _meep.first_field_component

def flip(d):
    return _meep.flip(d)
flip = _meep.flip

def has_direction(dim, d):
    return _meep.has_direction(dim, d)
has_direction = _meep.has_direction

def has_field_direction(dim, d):
    return _meep.has_field_direction(dim, d)
has_field_direction = _meep.has_field_direction

def is_tm(c):
    return _meep.is_tm(c)
is_tm = _meep.is_tm

def abort(arg1):
    return _meep.abort(arg1)
abort = _meep.abort

def is_electric(c):
    return _meep.is_electric(c)
is_electric = _meep.is_electric

def is_magnetic(c):
    return _meep.is_magnetic(c)
is_magnetic = _meep.is_magnetic

def is_D(c):
    return _meep.is_D(c)
is_D = _meep.is_D

def is_B(c):
    return _meep.is_B(c)
is_B = _meep.is_B

def is_derived(c):
    return _meep.is_derived(c)
is_derived = _meep.is_derived

def is_poynting(c):
    return _meep.is_poynting(c)
is_poynting = _meep.is_poynting

def is_energydensity(c):
    return _meep.is_energydensity(c)
is_energydensity = _meep.is_energydensity

def meep_type(c):
    return _meep.meep_type(c)
meep_type = _meep.meep_type

def component_name(*args):
    return _meep.component_name(*args)
component_name = _meep.component_name

def direction_name(arg1):
    return _meep.direction_name(arg1)
direction_name = _meep.direction_name

def dimension_name(arg1):
    return _meep.dimension_name(arg1)
dimension_name = _meep.dimension_name

def component_index(c):
    return _meep.component_index(c)
component_index = _meep.component_index

def component_direction(*args):
    return _meep.component_direction(*args)
component_direction = _meep.component_direction

def direction_component(*args):
    return _meep.direction_component(*args)
direction_component = _meep.direction_component

def field_type_component(ft, c):
    return _meep.field_type_component(ft, c)
field_type_component = _meep.field_type_component

def coordinate_mismatch(*args):
    return _meep.coordinate_mismatch(*args)
coordinate_mismatch = _meep.coordinate_mismatch

def cycle_direction(dim, d, shift):
    return _meep.cycle_direction(dim, d, shift)
cycle_direction = _meep.cycle_direction

def cycle_component(dim, c, shift):
    return _meep.cycle_component(dim, c, shift)
cycle_component = _meep.cycle_component

def veccyl(rr, zz):
    return _meep.veccyl(rr, zz)
veccyl = _meep.veccyl

def zero_vec(arg1):
    return _meep.zero_vec(arg1)
zero_vec = _meep.zero_vec
class vec(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vec, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_vec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_vec
    __del__ = lambda self: None

    def __add__(self, a):
        return _meep.vec___add__(self, a)

    def __iadd__(self, a):
        return _meep.vec___iadd__(self, a)

    def __sub__(self, a):
        return _meep.vec___sub__(self, a)

    def __neg__(self):
        return _meep.vec___neg__(self)

    def __isub__(self, a):
        return _meep.vec___isub__(self, a)

    def __ne__(self, a):
        return _meep.vec___ne__(self, a)

    def __eq__(self, a):
        return _meep.vec___eq__(self, a)

    def round_float(self):
        return _meep.vec_round_float(self)

    def __mul__(self, s):
        return _meep.vec___mul__(self, s)

    def __truediv__(self, *args):
        return _meep.vec___truediv__(self, *args)
    __div__ = __truediv__



    def __and__(self, a):
        return _meep.vec___and__(self, a)
    __swig_setmethods__["dim"] = _meep.vec_dim_set
    __swig_getmethods__["dim"] = _meep.vec_dim_get
    if _newclass:
        dim = _swig_property(_meep.vec_dim_get, _meep.vec_dim_set)

    def r(self):
        return _meep.vec_r(self)

    def x(self):
        return _meep.vec_x(self)

    def y(self):
        return _meep.vec_y(self)

    def z(self):
        return _meep.vec_z(self)

    def in_direction(self, d):
        return _meep.vec_in_direction(self, d)

    def set_direction(self, d, val):
        return _meep.vec_set_direction(self, d, val)

    def project_to_boundary(self, arg2, boundary_loc):
        return _meep.vec_project_to_boundary(self, arg2, boundary_loc)
vec_swigregister = _meep.vec_swigregister
vec_swigregister(vec)

def vec_from_dim(di, val):
    val = _meep.new_vec_from_dim(di, val)
    return val


def vec_abs(pt):
    return _meep.vec_abs(pt)
vec_abs = _meep.vec_abs

def one_vec(di):
    return _meep.one_vec(di)
one_vec = _meep.one_vec

def unit_vec(di, d):
    return _meep.unit_vec(di, d)
unit_vec = _meep.unit_vec

def clean_vec(pt, val_unused=0.0):
    return _meep.clean_vec(pt, val_unused)
clean_vec = _meep.clean_vec

def iveccyl(xx, yy):
    return _meep.iveccyl(xx, yy)
iveccyl = _meep.iveccyl

def zero_ivec(arg1):
    return _meep.zero_ivec(arg1)
zero_ivec = _meep.zero_ivec

def one_ivec(arg1):
    return _meep.one_ivec(arg1)
one_ivec = _meep.one_ivec
class ivec(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ivec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ivec, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_ivec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_ivec
    __del__ = lambda self: None

    def yucky_val(self, arg2):
        return _meep.ivec_yucky_val(self, arg2)

    def __add__(self, a):
        return _meep.ivec___add__(self, a)

    def __iadd__(self, a):
        return _meep.ivec___iadd__(self, a)

    def __sub__(self, a):
        return _meep.ivec___sub__(self, a)

    def __neg__(self):
        return _meep.ivec___neg__(self)

    def __isub__(self, a):
        return _meep.ivec___isub__(self, a)

    def __ne__(self, a):
        return _meep.ivec___ne__(self, a)

    def __eq__(self, a):
        return _meep.ivec___eq__(self, a)

    def __le__(self, a):
        return _meep.ivec___le__(self, a)

    def __ge__(self, a):
        return _meep.ivec___ge__(self, a)

    def __lt__(self, a):
        return _meep.ivec___lt__(self, a)

    def __gt__(self, a):
        return _meep.ivec___gt__(self, a)

    def __mul__(self, *args):
        return _meep.ivec___mul__(self, *args)
    __swig_setmethods__["dim"] = _meep.ivec_dim_set
    __swig_getmethods__["dim"] = _meep.ivec_dim_get
    if _newclass:
        dim = _swig_property(_meep.ivec_dim_get, _meep.ivec_dim_set)

    def r(self):
        return _meep.ivec_r(self)

    def x(self):
        return _meep.ivec_x(self)

    def y(self):
        return _meep.ivec_y(self)

    def z(self):
        return _meep.ivec_z(self)

    def in_direction(self, d):
        return _meep.ivec_in_direction(self, d)

    def set_direction(self, d, val):
        return _meep.ivec_set_direction(self, d, val)

    def round_up_to_even(self):
        return _meep.ivec_round_up_to_even(self)
ivec_swigregister = _meep.ivec_swigregister
ivec_swigregister(ivec)


def unit_ivec(di, d):
    return _meep.unit_ivec(di, d)
unit_ivec = _meep.unit_ivec

def vec_max(*args):
    return _meep.vec_max(*args)
vec_max = _meep.vec_max

def vec_min(*args):
    return _meep.vec_min(*args)
vec_min = _meep.vec_min
class volume(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, volume, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, volume, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dim"] = _meep.volume_dim_set
    __swig_getmethods__["dim"] = _meep.volume_dim_get
    if _newclass:
        dim = _swig_property(_meep.volume_dim_get, _meep.volume_dim_set)

    def __init__(self, *args):
        this = _meep.new_volume(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_direction_min(self, d, val):
        return _meep.volume_set_direction_min(self, d, val)

    def set_direction_max(self, d, val):
        return _meep.volume_set_direction_max(self, d, val)

    def in_direction_min(self, d):
        return _meep.volume_in_direction_min(self, d)

    def in_direction_max(self, d):
        return _meep.volume_in_direction_max(self, d)

    def in_direction(self, d):
        return _meep.volume_in_direction(self, d)

    def computational_volume(self):
        return _meep.volume_computational_volume(self)

    def integral_volume(self):
        return _meep.volume_integral_volume(self)

    def full_volume(self):
        return _meep.volume_full_volume(self)

    def center(self):
        return _meep.volume_center(self)

    def diameter(self):
        return _meep.volume_diameter(self)

    def contains(self, *args):
        return _meep.volume_contains(self, *args)

    def intersect_with(self, a):
        return _meep.volume_intersect_with(self, a)

    def __and__(self, a):
        return _meep.volume___and__(self, a)

    def __or__(self, a):
        return _meep.volume___or__(self, a)

    def __add__(self, a):
        return _meep.volume___add__(self, a)

    def __iadd__(self, a):
        return _meep.volume___iadd__(self, a)

    def __sub__(self, a):
        return _meep.volume___sub__(self, a)

    def __isub__(self, a):
        return _meep.volume___isub__(self, a)

    def __eq__(self, a):
        return _meep.volume___eq__(self, a)

    def __ne__(self, a):
        return _meep.volume___ne__(self, a)

    def round_float(self):
        return _meep.volume_round_float(self)

    def intersects(self, a):
        return _meep.volume_intersects(self, a)

    def __contains__(self, a):
        return _meep.volume___contains__(self, a)

    def get_min_corner(self):
        return _meep.volume_get_min_corner(self)

    def get_max_corner(self):
        return _meep.volume_get_max_corner(self)

    def normal_direction(self):
        return _meep.volume_normal_direction(self)
    __swig_destroy__ = _meep.delete_volume
    __del__ = lambda self: None
volume_swigregister = _meep.volume_swigregister
volume_swigregister(volume)


def volcyl(rsize, zsize, a):
    return _meep.volcyl(rsize, zsize, a)
volcyl = _meep.volcyl

def volone(zsize, a):
    return _meep.volone(zsize, a)
volone = _meep.volone

def vol1d(zsize, a):
    return _meep.vol1d(zsize, a)
vol1d = _meep.vol1d

def voltwo(xsize, ysize, a):
    return _meep.voltwo(xsize, ysize, a)
voltwo = _meep.voltwo

def vol2d(xsize, ysize, a):
    return _meep.vol2d(xsize, ysize, a)
vol2d = _meep.vol2d

def vol3d(xsize, ysize, zsize, a):
    return _meep.vol3d(xsize, ysize, zsize, a)
vol3d = _meep.vol3d
class grid_volume(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, grid_volume, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, grid_volume, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _meep.new_grid_volume()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["dim"] = _meep.grid_volume_dim_set
    __swig_getmethods__["dim"] = _meep.grid_volume_dim_get
    if _newclass:
        dim = _swig_property(_meep.grid_volume_dim_get, _meep.grid_volume_dim_set)
    __swig_setmethods__["a"] = _meep.grid_volume_a_set
    __swig_getmethods__["a"] = _meep.grid_volume_a_get
    if _newclass:
        a = _swig_property(_meep.grid_volume_a_get, _meep.grid_volume_a_set)
    __swig_setmethods__["inva"] = _meep.grid_volume_inva_set
    __swig_getmethods__["inva"] = _meep.grid_volume_inva_get
    if _newclass:
        inva = _swig_property(_meep.grid_volume_inva_get, _meep.grid_volume_inva_set)

    def print_grid_volume(self):
        return _meep.grid_volume_print_grid_volume(self)

    def stride(self, d):
        return _meep.grid_volume_stride(self, d)

    def num_direction(self, d):
        return _meep.grid_volume_num_direction(self, d)

    def yucky_num(self, arg2):
        return _meep.grid_volume_yucky_num(self, arg2)

    def yucky_direction(self, arg2):
        return _meep.grid_volume_yucky_direction(self, arg2)

    def set_num_direction(self, d, value):
        return _meep.grid_volume_set_num_direction(self, d, value)

    def nr(self):
        return _meep.grid_volume_nr(self)

    def nx(self):
        return _meep.grid_volume_nx(self)

    def ny(self):
        return _meep.grid_volume_ny(self)

    def nz(self):
        return _meep.grid_volume_nz(self)

    def has_field(self, c):
        return _meep.grid_volume_has_field(self, c)

    def has_boundary(self, arg2, arg3):
        return _meep.grid_volume_has_boundary(self, arg2, arg3)

    def dr(self):
        return _meep.grid_volume_dr(self)

    def dx(self):
        return _meep.grid_volume_dx(self)

    def dy(self):
        return _meep.grid_volume_dy(self)

    def dz(self):
        return _meep.grid_volume_dz(self)

    def ntot(self):
        return _meep.grid_volume_ntot(self)

    def nowned_min(self):
        return _meep.grid_volume_nowned_min(self)

    def nowned(self, c):
        return _meep.grid_volume_nowned(self, c)

    def __getitem__(self, p):
        return _meep.grid_volume___getitem__(self, p)

    def index(self, arg2, arg3):
        return _meep.grid_volume_index(self, arg2, arg3)

    def round_vec(self, arg2):
        return _meep.grid_volume_round_vec(self, arg2)

    def interpolate(self, *args):
        return _meep.grid_volume_interpolate(self, *args)

    def dV(self, *args):
        return _meep.grid_volume_dV(self, *args)

    def intersect_with(self, vol_in, intersection=None, others=None, num_others=None):
        return _meep.grid_volume_intersect_with(self, vol_in, intersection, others, num_others)

    def rmin(self):
        return _meep.grid_volume_rmin(self)

    def rmax(self):
        return _meep.grid_volume_rmax(self)

    def xmin(self):
        return _meep.grid_volume_xmin(self)

    def xmax(self):
        return _meep.grid_volume_xmax(self)

    def ymin(self):
        return _meep.grid_volume_ymin(self)

    def ymax(self):
        return _meep.grid_volume_ymax(self)

    def zmin(self):
        return _meep.grid_volume_zmin(self)

    def zmax(self):
        return _meep.grid_volume_zmax(self)

    def center(self):
        return _meep.grid_volume_center(self)

    def icenter(self):
        return _meep.grid_volume_icenter(self)

    def loc(self, arg2, index):
        return _meep.grid_volume_loc(self, arg2, index)

    def loc_at_resolution(self, index, res):
        return _meep.grid_volume_loc_at_resolution(self, index, res)

    def ntot_at_resolution(self, res):
        return _meep.grid_volume_ntot_at_resolution(self, res)

    def iloc(self, arg2, index):
        return _meep.grid_volume_iloc(self, arg2, index)

    def yee_index(self, c):
        return _meep.grid_volume_yee_index(self, c)

    def yee_shift(self, arg2):
        return _meep.grid_volume_yee_shift(self, arg2)

    def eps_component(self):
        return _meep.grid_volume_eps_component(self)

    def yee2cent_offsets(self, c, offset1, offset2):
        return _meep.grid_volume_yee2cent_offsets(self, c, offset1, offset2)

    def cent2yee_offsets(self, c, offset1, offset2):
        return _meep.grid_volume_cent2yee_offsets(self, c, offset1, offset2)

    def boundary_location(self, arg2, arg3):
        return _meep.grid_volume_boundary_location(self, arg2, arg3)

    def big_corner(self):
        return _meep.grid_volume_big_corner(self)

    def little_corner(self):
        return _meep.grid_volume_little_corner(self)

    def corner(self, b):
        return _meep.grid_volume_corner(self, b)

    def contains(self, *args):
        return _meep.grid_volume_contains(self, *args)

    def little_owned_corner0(self, c):
        return _meep.grid_volume_little_owned_corner0(self, c)

    def little_owned_corner(self, c):
        return _meep.grid_volume_little_owned_corner(self, c)

    def owns(self, arg2):
        return _meep.grid_volume_owns(self, arg2)

    def surroundings(self):
        return _meep.grid_volume_surroundings(self)

    def interior(self):
        return _meep.grid_volume_interior(self)

    def get_boundary_icorners(self, c, ib, cs, ce):
        return _meep.grid_volume_get_boundary_icorners(self, c, ib, cs, ce)

    def split(self, num, which):
        return _meep.grid_volume_split(self, num, which)

    def split_by_effort(self, num, which, Ngv=0, v=None, effort=None):
        return _meep.grid_volume_split_by_effort(self, num, which, Ngv, v, effort)

    def split_at_fraction(self, want_high, numer):
        return _meep.grid_volume_split_at_fraction(self, want_high, numer)

    def halve(self, d):
        return _meep.grid_volume_halve(self, d)

    def pad_self(self, d):
        return _meep.grid_volume_pad_self(self, d)

    def pad(self, *args):
        return _meep.grid_volume_pad(self, *args)

    def iyee_shift(self, c):
        return _meep.grid_volume_iyee_shift(self, c)

    def get_origin(self):
        return _meep.grid_volume_get_origin(self)

    def shift_origin(self, *args):
        return _meep.grid_volume_shift_origin(self, *args)

    def set_origin(self, *args):
        return _meep.grid_volume_set_origin(self, *args)

    def center_origin(self):
        return _meep.grid_volume_center_origin(self)

    def origin_in_direction(self, d):
        return _meep.grid_volume_origin_in_direction(self, d)

    def iorigin_in_direction(self, d):
        return _meep.grid_volume_iorigin_in_direction(self, d)

    def origin_r(self):
        return _meep.grid_volume_origin_r(self)

    def origin_x(self):
        return _meep.grid_volume_origin_x(self)

    def origin_y(self):
        return _meep.grid_volume_origin_y(self)

    def origin_z(self):
        return _meep.grid_volume_origin_z(self)
    __swig_destroy__ = _meep.delete_grid_volume
    __del__ = lambda self: None
grid_volume_swigregister = _meep.grid_volume_swigregister
grid_volume_swigregister(grid_volume)


def identity():
    return _meep.identity()
identity = _meep.identity

def rotate4(arg1, arg2):
    return _meep.rotate4(arg1, arg2)
rotate4 = _meep.rotate4

def rotate2(arg1, arg2):
    return _meep.rotate2(arg1, arg2)
rotate2 = _meep.rotate2

def mirror(arg1, arg2):
    return _meep.mirror(arg1, arg2)
mirror = _meep.mirror

def r_to_minus_r_symmetry(m):
    return _meep.r_to_minus_r_symmetry(m)
r_to_minus_r_symmetry = _meep.r_to_minus_r_symmetry
class symmetry(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, symmetry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, symmetry, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_symmetry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_symmetry
    __del__ = lambda self: None

    def transform_unshifted(self, arg2, n):
        return _meep.symmetry_transform_unshifted(self, arg2, n)

    def transform(self, *args):
        return _meep.symmetry_transform(self, *args)

    def phase_shift(self, *args):
        return _meep.symmetry_phase_shift(self, *args)

    def multiplicity(self):
        return _meep.symmetry_multiplicity(self)

    def is_primitive(self, arg2):
        return _meep.symmetry_is_primitive(self, arg2)

    def symmetry_reduce(self, gl):
        return _meep.symmetry_symmetry_reduce(self, gl)

    def __add__(self, arg2):
        return _meep.symmetry___add__(self, arg2)

    def __mul__(self, arg2):
        return _meep.symmetry___mul__(self, arg2)

    def __sub__(self, b):
        return _meep.symmetry___sub__(self, b)

    def __neg__(self):
        return _meep.symmetry___neg__(self)

    def symmetry_assign(self, arg2):
        return _meep.symmetry_symmetry_assign(self, arg2)

    def __eq__(self, arg2):
        return _meep.symmetry___eq__(self, arg2)

    def __ne__(self, S):
        return _meep.symmetry___ne__(self, S)
symmetry_swigregister = _meep.symmetry_swigregister
symmetry_swigregister(symmetry)

class volume_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, volume_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, volume_list, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _meep.delete_volume_list
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _meep.new_volume_list(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["v"] = _meep.volume_list_v_set
    __swig_getmethods__["v"] = _meep.volume_list_v_get
    if _newclass:
        v = _swig_property(_meep.volume_list_v_get, _meep.volume_list_v_set)
    __swig_setmethods__["c"] = _meep.volume_list_c_set
    __swig_getmethods__["c"] = _meep.volume_list_c_get
    if _newclass:
        c = _swig_property(_meep.volume_list_c_get, _meep.volume_list_c_set)
    __swig_setmethods__["weight"] = _meep.volume_list_weight_set
    __swig_getmethods__["weight"] = _meep.volume_list_weight_get
    if _newclass:
        weight = _swig_property(_meep.volume_list_weight_get, _meep.volume_list_weight_set)
    __swig_setmethods__["next"] = _meep.volume_list_next_set
    __swig_getmethods__["next"] = _meep.volume_list_next_get
    if _newclass:
        next = _swig_property(_meep.volume_list_next_get, _meep.volume_list_next_set)
volume_list_swigregister = _meep.volume_list_swigregister
volume_list_swigregister(volume_list)

MEEP_SINGLE = _meep.MEEP_SINGLE
class susceptibility(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, susceptibility, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, susceptibility, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_susceptibility(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        return _meep.susceptibility_clone(self)
    __swig_destroy__ = _meep.delete_susceptibility
    __del__ = lambda self: None

    def get_id(self):
        return _meep.susceptibility_get_id(self)

    def __eq__(self, s):
        return _meep.susceptibility___eq__(self, s)

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def subtract_P(self, ft, f_minus_p, P_internal_data):
        return _meep.susceptibility_subtract_P(self, ft, f_minus_p, P_internal_data)

    def needs_P(self, c, cmp, W):
        return _meep.susceptibility_needs_P(self, c, cmp, W)

    def needs_W_notowned(self, c, W):
        return _meep.susceptibility_needs_W_notowned(self, c, W)

    def needs_W_prev(self):
        return _meep.susceptibility_needs_W_prev(self)

    def new_internal_data(self, W, gv):
        return _meep.susceptibility_new_internal_data(self, W, gv)

    def delete_internal_data(self, data):
        return _meep.susceptibility_delete_internal_data(self, data)

    def init_internal_data(self, W, dt, gv, data):
        return _meep.susceptibility_init_internal_data(self, W, dt, gv, data)

    def copy_internal_data(self, data):
        return _meep.susceptibility_copy_internal_data(self, data)

    def num_internal_notowned_needed(self, c, P_internal_data):
        return _meep.susceptibility_num_internal_notowned_needed(self, c, P_internal_data)

    def internal_notowned_ptr(self, inotowned, c, n, P_internal_data):
        return _meep.susceptibility_internal_notowned_ptr(self, inotowned, c, n, P_internal_data)

    def num_cinternal_notowned_needed(self, c, P_internal_data):
        return _meep.susceptibility_num_cinternal_notowned_needed(self, c, P_internal_data)

    def cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data):
        return _meep.susceptibility_cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data)
    __swig_setmethods__["next"] = _meep.susceptibility_next_set
    __swig_getmethods__["next"] = _meep.susceptibility_next_get
    if _newclass:
        next = _swig_property(_meep.susceptibility_next_get, _meep.susceptibility_next_set)
    __swig_setmethods__["ntot"] = _meep.susceptibility_ntot_set
    __swig_getmethods__["ntot"] = _meep.susceptibility_ntot_get
    if _newclass:
        ntot = _swig_property(_meep.susceptibility_ntot_get, _meep.susceptibility_ntot_set)
    __swig_setmethods__["sigma"] = _meep.susceptibility_sigma_set
    __swig_getmethods__["sigma"] = _meep.susceptibility_sigma_get
    if _newclass:
        sigma = _swig_property(_meep.susceptibility_sigma_get, _meep.susceptibility_sigma_set)
    __swig_setmethods__["trivial_sigma"] = _meep.susceptibility_trivial_sigma_set
    __swig_getmethods__["trivial_sigma"] = _meep.susceptibility_trivial_sigma_get
    if _newclass:
        trivial_sigma = _swig_property(_meep.susceptibility_trivial_sigma_get, _meep.susceptibility_trivial_sigma_set)
susceptibility_swigregister = _meep.susceptibility_swigregister
susceptibility_swigregister(susceptibility)
pi = cvar.pi
nan = cvar.nan

class lorentzian_susceptibility(susceptibility):
    __swig_setmethods__ = {}
    for _s in [susceptibility]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, lorentzian_susceptibility, name, value)
    __swig_getmethods__ = {}
    for _s in [susceptibility]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, lorentzian_susceptibility, name)
    __repr__ = _swig_repr

    def __init__(self, omega_0, gamma, no_omega_0_denominator=False):
        this = _meep.new_lorentzian_susceptibility(omega_0, gamma, no_omega_0_denominator)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        return _meep.lorentzian_susceptibility_clone(self)
    __swig_destroy__ = _meep.delete_lorentzian_susceptibility
    __del__ = lambda self: None

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.lorentzian_susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def subtract_P(self, ft, f_minus_p, P_internal_data):
        return _meep.lorentzian_susceptibility_subtract_P(self, ft, f_minus_p, P_internal_data)

    def new_internal_data(self, W, gv):
        return _meep.lorentzian_susceptibility_new_internal_data(self, W, gv)

    def init_internal_data(self, W, dt, gv, data):
        return _meep.lorentzian_susceptibility_init_internal_data(self, W, dt, gv, data)

    def copy_internal_data(self, data):
        return _meep.lorentzian_susceptibility_copy_internal_data(self, data)

    def num_cinternal_notowned_needed(self, c, P_internal_data):
        return _meep.lorentzian_susceptibility_num_cinternal_notowned_needed(self, c, P_internal_data)

    def cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data):
        return _meep.lorentzian_susceptibility_cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data)
lorentzian_susceptibility_swigregister = _meep.lorentzian_susceptibility_swigregister
lorentzian_susceptibility_swigregister(lorentzian_susceptibility)

class noisy_lorentzian_susceptibility(lorentzian_susceptibility):
    __swig_setmethods__ = {}
    for _s in [lorentzian_susceptibility]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, noisy_lorentzian_susceptibility, name, value)
    __swig_getmethods__ = {}
    for _s in [lorentzian_susceptibility]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, noisy_lorentzian_susceptibility, name)
    __repr__ = _swig_repr

    def __init__(self, noise_amp, omega_0, gamma, no_omega_0_denominator=False):
        this = _meep.new_noisy_lorentzian_susceptibility(noise_amp, omega_0, gamma, no_omega_0_denominator)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        return _meep.noisy_lorentzian_susceptibility_clone(self)

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.noisy_lorentzian_susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)
    __swig_destroy__ = _meep.delete_noisy_lorentzian_susceptibility
    __del__ = lambda self: None
noisy_lorentzian_susceptibility_swigregister = _meep.noisy_lorentzian_susceptibility_swigregister
noisy_lorentzian_susceptibility_swigregister(noisy_lorentzian_susceptibility)

class multilevel_susceptibility(susceptibility):
    __swig_setmethods__ = {}
    for _s in [susceptibility]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, multilevel_susceptibility, name, value)
    __swig_getmethods__ = {}
    for _s in [susceptibility]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, multilevel_susceptibility, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_multilevel_susceptibility(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        return _meep.multilevel_susceptibility_clone(self)
    __swig_destroy__ = _meep.delete_multilevel_susceptibility
    __del__ = lambda self: None

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.multilevel_susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def subtract_P(self, ft, f_minus_p, P_internal_data):
        return _meep.multilevel_susceptibility_subtract_P(self, ft, f_minus_p, P_internal_data)

    def new_internal_data(self, W, gv):
        return _meep.multilevel_susceptibility_new_internal_data(self, W, gv)

    def init_internal_data(self, W, dt, gv, data):
        return _meep.multilevel_susceptibility_init_internal_data(self, W, dt, gv, data)

    def copy_internal_data(self, data):
        return _meep.multilevel_susceptibility_copy_internal_data(self, data)

    def delete_internal_data(self, data):
        return _meep.multilevel_susceptibility_delete_internal_data(self, data)

    def num_cinternal_notowned_needed(self, c, P_internal_data):
        return _meep.multilevel_susceptibility_num_cinternal_notowned_needed(self, c, P_internal_data)

    def cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data):
        return _meep.multilevel_susceptibility_cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data)

    def needs_W_notowned(self, c, W):
        return _meep.multilevel_susceptibility_needs_W_notowned(self, c, W)

    def needs_W_prev(self):
        return _meep.multilevel_susceptibility_needs_W_prev(self)
multilevel_susceptibility_swigregister = _meep.multilevel_susceptibility_swigregister
multilevel_susceptibility_swigregister(multilevel_susceptibility)

class h5file(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, h5file, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, h5file, name)
    __repr__ = _swig_repr
    READONLY = _meep.h5file_READONLY
    READWRITE = _meep.h5file_READWRITE
    WRITE = _meep.h5file_WRITE

    def __init__(self, *args):
        this = _meep.new_h5file(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_h5file
    __del__ = lambda self: None

    def ok(self):
        return _meep.h5file_ok(self)

    def read(self, *args):
        return _meep.h5file_read(self, *args)

    def write(self, *args):
        return _meep.h5file_write(self, *args)

    def create_data(self, dataname, rank, dims, append_data=False, single_precision=True):
        return _meep.h5file_create_data(self, dataname, rank, dims, append_data, single_precision)

    def extend_data(self, dataname, rank, dims):
        return _meep.h5file_extend_data(self, dataname, rank, dims)

    def create_or_extend_data(self, dataname, rank, dims, append_data, single_precision):
        return _meep.h5file_create_or_extend_data(self, dataname, rank, dims, append_data, single_precision)

    def write_chunk(self, *args):
        return _meep.h5file_write_chunk(self, *args)

    def done_writing_chunks(self):
        return _meep.h5file_done_writing_chunks(self)

    def read_size(self, dataname, rank, dims, maxrank):
        return _meep.h5file_read_size(self, dataname, rank, dims, maxrank)

    def read_chunk(self, *args):
        return _meep.h5file_read_chunk(self, *args)

    def remove(self):
        return _meep.h5file_remove(self)

    def remove_data(self, dataname):
        return _meep.h5file_remove_data(self, dataname)

    def file_name(self):
        return _meep.h5file_file_name(self)

    def prevent_deadlock(self):
        return _meep.h5file_prevent_deadlock(self)
    __swig_setmethods__["extending"] = _meep.h5file_extending_set
    __swig_getmethods__["extending"] = _meep.h5file_extending_get
    if _newclass:
        extending = _swig_property(_meep.h5file_extending_get, _meep.h5file_extending_set)

    def get_extending(self, dataname):
        return _meep.h5file_get_extending(self, dataname)
h5file_swigregister = _meep.h5file_swigregister
h5file_swigregister(h5file)

DEFAULT_SUBPIXEL_TOL = _meep.DEFAULT_SUBPIXEL_TOL
DEFAULT_SUBPIXEL_MAXEVAL = _meep.DEFAULT_SUBPIXEL_MAXEVAL
class material_function(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, material_function, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, material_function, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _meep.new_material_function()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_material_function
    __del__ = lambda self: None

    def set_volume(self, v):
        return _meep.material_function_set_volume(self, v)

    def unset_volume(self):
        return _meep.material_function_unset_volume(self)

    def chi1p1(self, ft, r):
        return _meep.material_function_chi1p1(self, ft, r)

    def eps(self, r):
        return _meep.material_function_eps(self, r)

    def has_mu(self):
        return _meep.material_function_has_mu(self)

    def mu(self, r):
        return _meep.material_function_mu(self, r)

    def has_conductivity(self, c):
        return _meep.material_function_has_conductivity(self, c)

    def conductivity(self, c, r):
        return _meep.material_function_conductivity(self, c, r)

    def normal_vector(self, ft, v):
        return _meep.material_function_normal_vector(self, ft, v)

    def eff_chi1inv_row(self, c, chi1inv_row, v, tol=1e-4, maxeval=100000):
        return _meep.material_function_eff_chi1inv_row(self, c, chi1inv_row, v, tol, maxeval)

    def sigma_row(self, c, sigrow, r):
        return _meep.material_function_sigma_row(self, c, sigrow, r)

    def has_chi3(self, c):
        return _meep.material_function_has_chi3(self, c)

    def chi3(self, c, r):
        return _meep.material_function_chi3(self, c, r)

    def has_chi2(self, c):
        return _meep.material_function_has_chi2(self, c)

    def chi2(self, c, r):
        return _meep.material_function_chi2(self, c, r)
material_function_swigregister = _meep.material_function_swigregister
material_function_swigregister(material_function)

class simple_material_function(material_function):
    __swig_setmethods__ = {}
    for _s in [material_function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, simple_material_function, name, value)
    __swig_getmethods__ = {}
    for _s in [material_function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, simple_material_function, name)
    __repr__ = _swig_repr

    def __init__(self, func):
        this = _meep.new_simple_material_function(func)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_simple_material_function
    __del__ = lambda self: None

    def chi1p1(self, ft, r):
        return _meep.simple_material_function_chi1p1(self, ft, r)

    def eps(self, r):
        return _meep.simple_material_function_eps(self, r)

    def mu(self, r):
        return _meep.simple_material_function_mu(self, r)

    def conductivity(self, c, r):
        return _meep.simple_material_function_conductivity(self, c, r)

    def sigma_row(self, c, sigrow, r):
        return _meep.simple_material_function_sigma_row(self, c, sigrow, r)

    def chi3(self, c, r):
        return _meep.simple_material_function_chi3(self, c, r)

    def chi2(self, c, r):
        return _meep.simple_material_function_chi2(self, c, r)
simple_material_function_swigregister = _meep.simple_material_function_swigregister
simple_material_function_swigregister(simple_material_function)

class structure_chunk(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, structure_chunk, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, structure_chunk, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a"] = _meep.structure_chunk_a_set
    __swig_getmethods__["a"] = _meep.structure_chunk_a_get
    if _newclass:
        a = _swig_property(_meep.structure_chunk_a_get, _meep.structure_chunk_a_set)
    __swig_setmethods__["Courant"] = _meep.structure_chunk_Courant_set
    __swig_getmethods__["Courant"] = _meep.structure_chunk_Courant_get
    if _newclass:
        Courant = _swig_property(_meep.structure_chunk_Courant_get, _meep.structure_chunk_Courant_set)
    __swig_setmethods__["dt"] = _meep.structure_chunk_dt_set
    __swig_getmethods__["dt"] = _meep.structure_chunk_dt_get
    if _newclass:
        dt = _swig_property(_meep.structure_chunk_dt_get, _meep.structure_chunk_dt_set)
    __swig_setmethods__["chi3"] = _meep.structure_chunk_chi3_set
    __swig_getmethods__["chi3"] = _meep.structure_chunk_chi3_get
    if _newclass:
        chi3 = _swig_property(_meep.structure_chunk_chi3_get, _meep.structure_chunk_chi3_set)
    __swig_setmethods__["chi2"] = _meep.structure_chunk_chi2_set
    __swig_getmethods__["chi2"] = _meep.structure_chunk_chi2_get
    if _newclass:
        chi2 = _swig_property(_meep.structure_chunk_chi2_get, _meep.structure_chunk_chi2_set)
    __swig_setmethods__["chi1inv"] = _meep.structure_chunk_chi1inv_set
    __swig_getmethods__["chi1inv"] = _meep.structure_chunk_chi1inv_get
    if _newclass:
        chi1inv = _swig_property(_meep.structure_chunk_chi1inv_get, _meep.structure_chunk_chi1inv_set)
    __swig_setmethods__["trivial_chi1inv"] = _meep.structure_chunk_trivial_chi1inv_set
    __swig_getmethods__["trivial_chi1inv"] = _meep.structure_chunk_trivial_chi1inv_get
    if _newclass:
        trivial_chi1inv = _swig_property(_meep.structure_chunk_trivial_chi1inv_get, _meep.structure_chunk_trivial_chi1inv_set)
    __swig_setmethods__["conductivity"] = _meep.structure_chunk_conductivity_set
    __swig_getmethods__["conductivity"] = _meep.structure_chunk_conductivity_get
    if _newclass:
        conductivity = _swig_property(_meep.structure_chunk_conductivity_get, _meep.structure_chunk_conductivity_set)
    __swig_setmethods__["condinv"] = _meep.structure_chunk_condinv_set
    __swig_getmethods__["condinv"] = _meep.structure_chunk_condinv_get
    if _newclass:
        condinv = _swig_property(_meep.structure_chunk_condinv_get, _meep.structure_chunk_condinv_set)
    __swig_setmethods__["condinv_stale"] = _meep.structure_chunk_condinv_stale_set
    __swig_getmethods__["condinv_stale"] = _meep.structure_chunk_condinv_stale_get
    if _newclass:
        condinv_stale = _swig_property(_meep.structure_chunk_condinv_stale_get, _meep.structure_chunk_condinv_stale_set)
    __swig_setmethods__["sig"] = _meep.structure_chunk_sig_set
    __swig_getmethods__["sig"] = _meep.structure_chunk_sig_get
    if _newclass:
        sig = _swig_property(_meep.structure_chunk_sig_get, _meep.structure_chunk_sig_set)
    __swig_setmethods__["kap"] = _meep.structure_chunk_kap_set
    __swig_getmethods__["kap"] = _meep.structure_chunk_kap_get
    if _newclass:
        kap = _swig_property(_meep.structure_chunk_kap_get, _meep.structure_chunk_kap_set)
    __swig_setmethods__["siginv"] = _meep.structure_chunk_siginv_set
    __swig_getmethods__["siginv"] = _meep.structure_chunk_siginv_get
    if _newclass:
        siginv = _swig_property(_meep.structure_chunk_siginv_get, _meep.structure_chunk_siginv_set)
    __swig_setmethods__["sigsize"] = _meep.structure_chunk_sigsize_set
    __swig_getmethods__["sigsize"] = _meep.structure_chunk_sigsize_get
    if _newclass:
        sigsize = _swig_property(_meep.structure_chunk_sigsize_get, _meep.structure_chunk_sigsize_set)
    __swig_setmethods__["gv"] = _meep.structure_chunk_gv_set
    __swig_getmethods__["gv"] = _meep.structure_chunk_gv_get
    if _newclass:
        gv = _swig_property(_meep.structure_chunk_gv_get, _meep.structure_chunk_gv_set)
    __swig_setmethods__["v"] = _meep.structure_chunk_v_set
    __swig_getmethods__["v"] = _meep.structure_chunk_v_get
    if _newclass:
        v = _swig_property(_meep.structure_chunk_v_get, _meep.structure_chunk_v_set)
    __swig_setmethods__["chiP"] = _meep.structure_chunk_chiP_set
    __swig_getmethods__["chiP"] = _meep.structure_chunk_chiP_get
    if _newclass:
        chiP = _swig_property(_meep.structure_chunk_chiP_get, _meep.structure_chunk_chiP_set)
    __swig_setmethods__["refcount"] = _meep.structure_chunk_refcount_set
    __swig_getmethods__["refcount"] = _meep.structure_chunk_refcount_get
    if _newclass:
        refcount = _swig_property(_meep.structure_chunk_refcount_get, _meep.structure_chunk_refcount_set)
    __swig_destroy__ = _meep.delete_structure_chunk
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _meep.new_structure_chunk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_chi1inv(self, c, eps, use_anisotropic_averaging, tol, maxeval):
        return _meep.structure_chunk_set_chi1inv(self, c, eps, use_anisotropic_averaging, tol, maxeval)

    def has_chi(self, c, d):
        return _meep.structure_chunk_has_chi(self, c, d)

    def has_chisigma(self, c, d):
        return _meep.structure_chunk_has_chisigma(self, c, d)

    def has_chi1inv(self, c, d):
        return _meep.structure_chunk_has_chi1inv(self, c, d)

    def set_conductivity(self, c, eps):
        return _meep.structure_chunk_set_conductivity(self, c, eps)

    def update_condinv(self):
        return _meep.structure_chunk_update_condinv(self)

    def set_chi3(self, c, eps):
        return _meep.structure_chunk_set_chi3(self, c, eps)

    def set_chi2(self, c, eps):
        return _meep.structure_chunk_set_chi2(self, c, eps)

    def use_pml(self, arg2, dx, boundary_loc, Rasymptotic, mean_stretch, pml_profile, pml_profile_data, pml_profile_integral, pml_profile_integral_u):
        return _meep.structure_chunk_use_pml(self, arg2, dx, boundary_loc, Rasymptotic, mean_stretch, pml_profile, pml_profile_data, pml_profile_integral, pml_profile_integral_u)

    def add_susceptibility(self, sigma, ft, sus):
        return _meep.structure_chunk_add_susceptibility(self, sigma, ft, sus)

    def mix_with(self, arg2, arg3):
        return _meep.structure_chunk_mix_with(self, arg2, arg3)

    def n_proc(self):
        return _meep.structure_chunk_n_proc(self)

    def is_mine(self):
        return _meep.structure_chunk_is_mine(self)

    def remove_susceptibilities(self):
        return _meep.structure_chunk_remove_susceptibilities(self)

    def get_chi1inv(self, arg2, arg3, iloc):
        return _meep.structure_chunk_get_chi1inv(self, arg2, arg3, iloc)

    def get_inveps(self, c, d, iloc):
        return _meep.structure_chunk_get_inveps(self, c, d, iloc)

    def max_eps(self):
        return _meep.structure_chunk_max_eps(self)
structure_chunk_swigregister = _meep.structure_chunk_swigregister
structure_chunk_swigregister(structure_chunk)


def pml_quadratic_profile(arg1, arg2):
    return _meep.pml_quadratic_profile(arg1, arg2)
pml_quadratic_profile = _meep.pml_quadratic_profile
class boundary_region(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, boundary_region, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, boundary_region, name)
    __repr__ = _swig_repr
    NOTHING_SPECIAL = _meep.boundary_region_NOTHING_SPECIAL
    PML = _meep.boundary_region_PML

    def __init__(self, *args):
        this = _meep.new_boundary_region(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_boundary_region
    __del__ = lambda self: None

    def boundary_region_assign(self, r):
        return _meep.boundary_region_boundary_region_assign(self, r)

    def __add__(self, r0):
        return _meep.boundary_region___add__(self, r0)

    def __mul__(self, strength_mult):
        return _meep.boundary_region___mul__(self, strength_mult)

    def br_apply(self, *args):
        return _meep.boundary_region_br_apply(self, *args)

    def check_ok(self, gv):
        return _meep.boundary_region_check_ok(self, gv)
boundary_region_swigregister = _meep.boundary_region_swigregister
boundary_region_swigregister(boundary_region)


def pml(*args):
    return _meep.pml(*args)
pml = _meep.pml
class structure(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, structure, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, structure, name)
    __repr__ = _swig_repr
    __swig_setmethods__["chunks"] = _meep.structure_chunks_set
    __swig_getmethods__["chunks"] = _meep.structure_chunks_get
    if _newclass:
        chunks = _swig_property(_meep.structure_chunks_get, _meep.structure_chunks_set)
    __swig_setmethods__["num_chunks"] = _meep.structure_num_chunks_set
    __swig_getmethods__["num_chunks"] = _meep.structure_num_chunks_get
    if _newclass:
        num_chunks = _swig_property(_meep.structure_num_chunks_get, _meep.structure_num_chunks_set)
    __swig_setmethods__["shared_chunks"] = _meep.structure_shared_chunks_set
    __swig_getmethods__["shared_chunks"] = _meep.structure_shared_chunks_get
    if _newclass:
        shared_chunks = _swig_property(_meep.structure_shared_chunks_get, _meep.structure_shared_chunks_set)
    __swig_setmethods__["gv"] = _meep.structure_gv_set
    __swig_getmethods__["gv"] = _meep.structure_gv_get
    if _newclass:
        gv = _swig_property(_meep.structure_gv_get, _meep.structure_gv_set)
    __swig_setmethods__["user_volume"] = _meep.structure_user_volume_set
    __swig_getmethods__["user_volume"] = _meep.structure_user_volume_get
    if _newclass:
        user_volume = _swig_property(_meep.structure_user_volume_get, _meep.structure_user_volume_set)
    __swig_setmethods__["a"] = _meep.structure_a_set
    __swig_getmethods__["a"] = _meep.structure_a_get
    if _newclass:
        a = _swig_property(_meep.structure_a_get, _meep.structure_a_set)
    __swig_setmethods__["Courant"] = _meep.structure_Courant_set
    __swig_getmethods__["Courant"] = _meep.structure_Courant_get
    if _newclass:
        Courant = _swig_property(_meep.structure_Courant_get, _meep.structure_Courant_set)
    __swig_setmethods__["dt"] = _meep.structure_dt_set
    __swig_getmethods__["dt"] = _meep.structure_dt_get
    if _newclass:
        dt = _swig_property(_meep.structure_dt_get, _meep.structure_dt_set)
    __swig_setmethods__["v"] = _meep.structure_v_set
    __swig_getmethods__["v"] = _meep.structure_v_get
    if _newclass:
        v = _swig_property(_meep.structure_v_get, _meep.structure_v_set)
    __swig_setmethods__["S"] = _meep.structure_S_set
    __swig_getmethods__["S"] = _meep.structure_S_get
    if _newclass:
        S = _swig_property(_meep.structure_S_get, _meep.structure_S_set)
    __swig_setmethods__["outdir"] = _meep.structure_outdir_set
    __swig_getmethods__["outdir"] = _meep.structure_outdir_get
    if _newclass:
        outdir = _swig_property(_meep.structure_outdir_get, _meep.structure_outdir_set)
    __swig_setmethods__["effort_volumes"] = _meep.structure_effort_volumes_set
    __swig_getmethods__["effort_volumes"] = _meep.structure_effort_volumes_get
    if _newclass:
        effort_volumes = _swig_property(_meep.structure_effort_volumes_get, _meep.structure_effort_volumes_set)
    __swig_setmethods__["effort"] = _meep.structure_effort_set
    __swig_getmethods__["effort"] = _meep.structure_effort_get
    if _newclass:
        effort = _swig_property(_meep.structure_effort_get, _meep.structure_effort_set)
    __swig_setmethods__["num_effort_volumes"] = _meep.structure_num_effort_volumes_set
    __swig_getmethods__["num_effort_volumes"] = _meep.structure_num_effort_volumes_get
    if _newclass:
        num_effort_volumes = _swig_property(_meep.structure_num_effort_volumes_get, _meep.structure_num_effort_volumes_set)
    __swig_destroy__ = _meep.delete_structure
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _meep.new_structure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_materials(self, mat, use_anisotropic_averaging=True, tol=1e-4, maxeval=100000):
        return _meep.structure_set_materials(self, mat, use_anisotropic_averaging, tol, maxeval)

    def set_chi1inv(self, c, eps, use_anisotropic_averaging=True, tol=1e-4, maxeval=100000):
        return _meep.structure_set_chi1inv(self, c, eps, use_anisotropic_averaging, tol, maxeval)

    def has_chi(self, c, d):
        return _meep.structure_has_chi(self, c, d)

    def set_epsilon(self, *args):
        return _meep.structure_set_epsilon(self, *args)

    def set_mu(self, *args):
        return _meep.structure_set_mu(self, *args)

    def set_conductivity(self, *args):
        return _meep.structure_set_conductivity(self, *args)

    def set_chi3(self, *args):
        return _meep.structure_set_chi3(self, *args)

    def set_chi2(self, *args):
        return _meep.structure_set_chi2(self, *args)

    def add_susceptibility(self, *args):
        return _meep.structure_add_susceptibility(self, *args)

    def remove_susceptibilities(self):
        return _meep.structure_remove_susceptibilities(self)

    def set_output_directory(self, name):
        return _meep.structure_set_output_directory(self, name)

    def mix_with(self, arg2, arg3):
        return _meep.structure_mix_with(self, arg2, arg3)

    def equal_layout(self, arg2):
        return _meep.structure_equal_layout(self, arg2)

    def print_layout(self):
        return _meep.structure_print_layout(self)

    def dump(self, filename):
        return _meep.structure_dump(self, filename)

    def load(self, filename):
        return _meep.structure_load(self, filename)

    def get_chi1inv(self, *args):
        return _meep.structure_get_chi1inv(self, *args)

    def get_inveps(self, *args):
        return _meep.structure_get_inveps(self, *args)

    def get_eps(self, loc):
        return _meep.structure_get_eps(self, loc)

    def get_mu(self, loc):
        return _meep.structure_get_mu(self, loc)

    def max_eps(self):
        return _meep.structure_max_eps(self)
structure_swigregister = _meep.structure_swigregister
structure_swigregister(structure)

class src_time(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, src_time, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, src_time, name)
    __repr__ = _swig_repr
    __swig_setmethods__["is_integrated"] = _meep.src_time_is_integrated_set
    __swig_getmethods__["is_integrated"] = _meep.src_time_is_integrated_get
    if _newclass:
        is_integrated = _swig_property(_meep.src_time_is_integrated_get, _meep.src_time_is_integrated_set)
    __swig_destroy__ = _meep.delete_src_time
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _meep.new_src_time(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def update(self, time, dt):
        return _meep.src_time_update(self, time, dt)

    def current(self, *args):
        return _meep.src_time_current(self, *args)

    def last_time_max(self, *args):
        return _meep.src_time_last_time_max(self, *args)

    def add_to(self, others, added):
        return _meep.src_time_add_to(self, others, added)
    __swig_setmethods__["next"] = _meep.src_time_next_set
    __swig_getmethods__["next"] = _meep.src_time_next_get
    if _newclass:
        next = _swig_property(_meep.src_time_next_get, _meep.src_time_next_set)

    def dipole(self, *args):
        return _meep.src_time_dipole(self, *args)

    def last_time(self):
        return _meep.src_time_last_time(self)

    def clone(self):
        return _meep.src_time_clone(self)

    def is_equal(self, t):
        return _meep.src_time_is_equal(self, t)

    def frequency(self):
        return _meep.src_time_frequency(self)

    def set_frequency(self, f):
        return _meep.src_time_set_frequency(self, f)
src_time_swigregister = _meep.src_time_swigregister
src_time_swigregister(src_time)


def src_times_equal(t1, t2):
    return _meep.src_times_equal(t1, t2)
src_times_equal = _meep.src_times_equal
class gaussian_src_time(src_time):
    __swig_setmethods__ = {}
    for _s in [src_time]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, gaussian_src_time, name, value)
    __swig_getmethods__ = {}
    for _s in [src_time]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, gaussian_src_time, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_gaussian_src_time(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_gaussian_src_time
    __del__ = lambda self: None

    def dipole(self, time):
        return _meep.gaussian_src_time_dipole(self, time)

    def last_time(self):
        return _meep.gaussian_src_time_last_time(self)

    def clone(self):
        return _meep.gaussian_src_time_clone(self)

    def is_equal(self, t):
        return _meep.gaussian_src_time_is_equal(self, t)

    def frequency(self):
        return _meep.gaussian_src_time_frequency(self)

    def set_frequency(self, f):
        return _meep.gaussian_src_time_set_frequency(self, f)
gaussian_src_time_swigregister = _meep.gaussian_src_time_swigregister
gaussian_src_time_swigregister(gaussian_src_time)

class continuous_src_time(src_time):
    __swig_setmethods__ = {}
    for _s in [src_time]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, continuous_src_time, name, value)
    __swig_getmethods__ = {}
    for _s in [src_time]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, continuous_src_time, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_continuous_src_time(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_continuous_src_time
    __del__ = lambda self: None

    def dipole(self, time):
        return _meep.continuous_src_time_dipole(self, time)

    def last_time(self):
        return _meep.continuous_src_time_last_time(self)

    def clone(self):
        return _meep.continuous_src_time_clone(self)

    def is_equal(self, t):
        return _meep.continuous_src_time_is_equal(self, t)

    def frequency(self):
        return _meep.continuous_src_time_frequency(self)

    def set_frequency(self, f):
        return _meep.continuous_src_time_set_frequency(self, f)
continuous_src_time_swigregister = _meep.continuous_src_time_swigregister
continuous_src_time_swigregister(continuous_src_time)

class custom_src_time(src_time):
    __swig_setmethods__ = {}
    for _s in [src_time]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, custom_src_time, name, value)
    __swig_getmethods__ = {}
    for _s in [src_time]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, custom_src_time, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_custom_src_time(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_custom_src_time
    __del__ = lambda self: None

    def current(self, time, dt):
        return _meep.custom_src_time_current(self, time, dt)

    def dipole(self, time):
        return _meep.custom_src_time_dipole(self, time)

    def last_time(self):
        return _meep.custom_src_time_last_time(self)

    def clone(self):
        return _meep.custom_src_time_clone(self)

    def is_equal(self, t):
        return _meep.custom_src_time_is_equal(self, t)
custom_src_time_swigregister = _meep.custom_src_time_swigregister
custom_src_time_swigregister(custom_src_time)

class monitor_point(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, monitor_point, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, monitor_point, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _meep.new_monitor_point()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_monitor_point
    __del__ = lambda self: None
    __swig_setmethods__["loc"] = _meep.monitor_point_loc_set
    __swig_getmethods__["loc"] = _meep.monitor_point_loc_get
    if _newclass:
        loc = _swig_property(_meep.monitor_point_loc_get, _meep.monitor_point_loc_set)
    __swig_setmethods__["t"] = _meep.monitor_point_t_set
    __swig_getmethods__["t"] = _meep.monitor_point_t_get
    if _newclass:
        t = _swig_property(_meep.monitor_point_t_get, _meep.monitor_point_t_set)
    __swig_setmethods__["f"] = _meep.monitor_point_f_set
    __swig_getmethods__["f"] = _meep.monitor_point_f_get
    if _newclass:
        f = _swig_property(_meep.monitor_point_f_get, _meep.monitor_point_f_set)
    __swig_setmethods__["next"] = _meep.monitor_point_next_set
    __swig_getmethods__["next"] = _meep.monitor_point_next_get
    if _newclass:
        next = _swig_property(_meep.monitor_point_next_get, _meep.monitor_point_next_set)

    def get_component(self, arg2):
        return _meep.monitor_point_get_component(self, arg2)

    def poynting_in_direction(self, *args):
        return _meep.monitor_point_poynting_in_direction(self, *args)

    def fourier_transform(self, w, a, f, numout, fmin=0.0, fmax=0.0, maxbands=100):
        return _meep.monitor_point_fourier_transform(self, w, a, f, numout, fmin, fmax, maxbands)

    def harminv(self, w, a, f, numout, fmin, fmax, maxbands):
        return _meep.monitor_point_harminv(self, w, a, f, numout, fmin, fmax, maxbands)
monitor_point_swigregister = _meep.monitor_point_swigregister
monitor_point_swigregister(monitor_point)

class dft_chunk(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_chunk, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_chunk, name)
    __repr__ = _swig_repr

    def __init__(self, fc_, is_, ie_, s0_, s1_, e0_, e1_, dV0_, dV1_, c_, use_centered_grid, phase_factor, shift_, S_, sn_, data_):
        this = _meep.new_dft_chunk(fc_, is_, ie_, s0_, s1_, e0_, e1_, dV0_, dV1_, c_, use_centered_grid, phase_factor, shift_, S_, sn_, data_)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_dft_chunk
    __del__ = lambda self: None

    def update_dft(self, time):
        return _meep.dft_chunk_update_dft(self, time)

    def scale_dft(self, scale):
        return _meep.dft_chunk_scale_dft(self, scale)

    def process_dft_component(self, rank, ds, min_corner, max_corner, num_freq, file, buffer, reim, field_array, mode1_data, mode2_data, c_conjugate):
        return _meep.dft_chunk_process_dft_component(self, rank, ds, min_corner, max_corner, num_freq, file, buffer, reim, field_array, mode1_data, mode2_data, c_conjugate)

    def __isub__(self, chunk):
        return _meep.dft_chunk___isub__(self, chunk)
    __swig_setmethods__["omega_min"] = _meep.dft_chunk_omega_min_set
    __swig_getmethods__["omega_min"] = _meep.dft_chunk_omega_min_get
    if _newclass:
        omega_min = _swig_property(_meep.dft_chunk_omega_min_get, _meep.dft_chunk_omega_min_set)
    __swig_setmethods__["domega"] = _meep.dft_chunk_domega_set
    __swig_getmethods__["domega"] = _meep.dft_chunk_domega_get
    if _newclass:
        domega = _swig_property(_meep.dft_chunk_domega_get, _meep.dft_chunk_domega_set)
    __swig_setmethods__["Nomega"] = _meep.dft_chunk_Nomega_set
    __swig_getmethods__["Nomega"] = _meep.dft_chunk_Nomega_get
    if _newclass:
        Nomega = _swig_property(_meep.dft_chunk_Nomega_get, _meep.dft_chunk_Nomega_set)
    __swig_setmethods__["c"] = _meep.dft_chunk_c_set
    __swig_getmethods__["c"] = _meep.dft_chunk_c_get
    if _newclass:
        c = _swig_property(_meep.dft_chunk_c_get, _meep.dft_chunk_c_set)
    __swig_setmethods__["N"] = _meep.dft_chunk_N_set
    __swig_getmethods__["N"] = _meep.dft_chunk_N_get
    if _newclass:
        N = _swig_property(_meep.dft_chunk_N_get, _meep.dft_chunk_N_set)
    __swig_setmethods__["dft"] = _meep.dft_chunk_dft_set
    __swig_getmethods__["dft"] = _meep.dft_chunk_dft_get
    if _newclass:
        dft = _swig_property(_meep.dft_chunk_dft_get, _meep.dft_chunk_dft_set)
    __swig_setmethods__["next_in_chunk"] = _meep.dft_chunk_next_in_chunk_set
    __swig_getmethods__["next_in_chunk"] = _meep.dft_chunk_next_in_chunk_get
    if _newclass:
        next_in_chunk = _swig_property(_meep.dft_chunk_next_in_chunk_get, _meep.dft_chunk_next_in_chunk_set)
    __swig_setmethods__["next_in_dft"] = _meep.dft_chunk_next_in_dft_set
    __swig_getmethods__["next_in_dft"] = _meep.dft_chunk_next_in_dft_get
    if _newclass:
        next_in_dft = _swig_property(_meep.dft_chunk_next_in_dft_get, _meep.dft_chunk_next_in_dft_set)
    __swig_setmethods__["stored_weight"] = _meep.dft_chunk_stored_weight_set
    __swig_getmethods__["stored_weight"] = _meep.dft_chunk_stored_weight_get
    if _newclass:
        stored_weight = _swig_property(_meep.dft_chunk_stored_weight_get, _meep.dft_chunk_stored_weight_set)
    __swig_setmethods__["include_dV_and_interp_weights"] = _meep.dft_chunk_include_dV_and_interp_weights_set
    __swig_getmethods__["include_dV_and_interp_weights"] = _meep.dft_chunk_include_dV_and_interp_weights_get
    if _newclass:
        include_dV_and_interp_weights = _swig_property(_meep.dft_chunk_include_dV_and_interp_weights_get, _meep.dft_chunk_include_dV_and_interp_weights_set)
    __swig_setmethods__["sqrt_dV_and_interp_weights"] = _meep.dft_chunk_sqrt_dV_and_interp_weights_set
    __swig_getmethods__["sqrt_dV_and_interp_weights"] = _meep.dft_chunk_sqrt_dV_and_interp_weights_get
    if _newclass:
        sqrt_dV_and_interp_weights = _swig_property(_meep.dft_chunk_sqrt_dV_and_interp_weights_get, _meep.dft_chunk_sqrt_dV_and_interp_weights_set)
    __swig_setmethods__["extra_weight"] = _meep.dft_chunk_extra_weight_set
    __swig_getmethods__["extra_weight"] = _meep.dft_chunk_extra_weight_get
    if _newclass:
        extra_weight = _swig_property(_meep.dft_chunk_extra_weight_get, _meep.dft_chunk_extra_weight_set)
    __swig_setmethods__["fc"] = _meep.dft_chunk_fc_set
    __swig_getmethods__["fc"] = _meep.dft_chunk_fc_get
    if _newclass:
        fc = _swig_property(_meep.dft_chunk_fc_get, _meep.dft_chunk_fc_set)
    __swig_setmethods__["_is"] = _meep.dft_chunk__is_set
    __swig_getmethods__["_is"] = _meep.dft_chunk__is_get
    if _newclass:
        _is = _swig_property(_meep.dft_chunk__is_get, _meep.dft_chunk__is_set)
    __swig_setmethods__["ie"] = _meep.dft_chunk_ie_set
    __swig_getmethods__["ie"] = _meep.dft_chunk_ie_get
    if _newclass:
        ie = _swig_property(_meep.dft_chunk_ie_get, _meep.dft_chunk_ie_set)
    __swig_setmethods__["s0"] = _meep.dft_chunk_s0_set
    __swig_getmethods__["s0"] = _meep.dft_chunk_s0_get
    if _newclass:
        s0 = _swig_property(_meep.dft_chunk_s0_get, _meep.dft_chunk_s0_set)
    __swig_setmethods__["s1"] = _meep.dft_chunk_s1_set
    __swig_getmethods__["s1"] = _meep.dft_chunk_s1_get
    if _newclass:
        s1 = _swig_property(_meep.dft_chunk_s1_get, _meep.dft_chunk_s1_set)
    __swig_setmethods__["e0"] = _meep.dft_chunk_e0_set
    __swig_getmethods__["e0"] = _meep.dft_chunk_e0_get
    if _newclass:
        e0 = _swig_property(_meep.dft_chunk_e0_get, _meep.dft_chunk_e0_set)
    __swig_setmethods__["e1"] = _meep.dft_chunk_e1_set
    __swig_getmethods__["e1"] = _meep.dft_chunk_e1_get
    if _newclass:
        e1 = _swig_property(_meep.dft_chunk_e1_get, _meep.dft_chunk_e1_set)
    __swig_setmethods__["dV0"] = _meep.dft_chunk_dV0_set
    __swig_getmethods__["dV0"] = _meep.dft_chunk_dV0_get
    if _newclass:
        dV0 = _swig_property(_meep.dft_chunk_dV0_get, _meep.dft_chunk_dV0_set)
    __swig_setmethods__["dV1"] = _meep.dft_chunk_dV1_set
    __swig_getmethods__["dV1"] = _meep.dft_chunk_dV1_get
    if _newclass:
        dV1 = _swig_property(_meep.dft_chunk_dV1_get, _meep.dft_chunk_dV1_set)
    __swig_setmethods__["scale"] = _meep.dft_chunk_scale_set
    __swig_getmethods__["scale"] = _meep.dft_chunk_scale_get
    if _newclass:
        scale = _swig_property(_meep.dft_chunk_scale_get, _meep.dft_chunk_scale_set)
    __swig_setmethods__["shift"] = _meep.dft_chunk_shift_set
    __swig_getmethods__["shift"] = _meep.dft_chunk_shift_get
    if _newclass:
        shift = _swig_property(_meep.dft_chunk_shift_get, _meep.dft_chunk_shift_set)
    __swig_setmethods__["S"] = _meep.dft_chunk_S_set
    __swig_getmethods__["S"] = _meep.dft_chunk_S_get
    if _newclass:
        S = _swig_property(_meep.dft_chunk_S_get, _meep.dft_chunk_S_set)
    __swig_setmethods__["sn"] = _meep.dft_chunk_sn_set
    __swig_getmethods__["sn"] = _meep.dft_chunk_sn_get
    if _newclass:
        sn = _swig_property(_meep.dft_chunk_sn_get, _meep.dft_chunk_sn_set)
    __swig_setmethods__["dft_phase"] = _meep.dft_chunk_dft_phase_set
    __swig_getmethods__["dft_phase"] = _meep.dft_chunk_dft_phase_get
    if _newclass:
        dft_phase = _swig_property(_meep.dft_chunk_dft_phase_get, _meep.dft_chunk_dft_phase_set)
    __swig_setmethods__["avg1"] = _meep.dft_chunk_avg1_set
    __swig_getmethods__["avg1"] = _meep.dft_chunk_avg1_get
    if _newclass:
        avg1 = _swig_property(_meep.dft_chunk_avg1_get, _meep.dft_chunk_avg1_set)
    __swig_setmethods__["avg2"] = _meep.dft_chunk_avg2_set
    __swig_getmethods__["avg2"] = _meep.dft_chunk_avg2_get
    if _newclass:
        avg2 = _swig_property(_meep.dft_chunk_avg2_get, _meep.dft_chunk_avg2_set)
    __swig_setmethods__["vc"] = _meep.dft_chunk_vc_set
    __swig_getmethods__["vc"] = _meep.dft_chunk_vc_get
    if _newclass:
        vc = _swig_property(_meep.dft_chunk_vc_get, _meep.dft_chunk_vc_set)
dft_chunk_swigregister = _meep.dft_chunk_swigregister
dft_chunk_swigregister(dft_chunk)


def save_dft_hdf5(*args):
    return _meep.save_dft_hdf5(*args)
save_dft_hdf5 = _meep.save_dft_hdf5

def load_dft_hdf5(*args):
    return _meep.load_dft_hdf5(*args)
load_dft_hdf5 = _meep.load_dft_hdf5
class dft_flux(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_flux, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_flux, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_dft_flux(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def flux(self):
        return _meep.dft_flux_flux(self)

    def __isub__(self, fl):
        return _meep.dft_flux___isub__(self, fl)

    def save_hdf5(self, *args):
        return _meep.dft_flux_save_hdf5(self, *args)

    def load_hdf5(self, *args):
        return _meep.dft_flux_load_hdf5(self, *args)

    def scale_dfts(self, scale):
        return _meep.dft_flux_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_flux_remove(self)
    __swig_setmethods__["freq_min"] = _meep.dft_flux_freq_min_set
    __swig_getmethods__["freq_min"] = _meep.dft_flux_freq_min_get
    if _newclass:
        freq_min = _swig_property(_meep.dft_flux_freq_min_get, _meep.dft_flux_freq_min_set)
    __swig_setmethods__["dfreq"] = _meep.dft_flux_dfreq_set
    __swig_getmethods__["dfreq"] = _meep.dft_flux_dfreq_get
    if _newclass:
        dfreq = _swig_property(_meep.dft_flux_dfreq_get, _meep.dft_flux_dfreq_set)
    __swig_setmethods__["Nfreq"] = _meep.dft_flux_Nfreq_set
    __swig_getmethods__["Nfreq"] = _meep.dft_flux_Nfreq_get
    if _newclass:
        Nfreq = _swig_property(_meep.dft_flux_Nfreq_get, _meep.dft_flux_Nfreq_set)
    __swig_setmethods__["E"] = _meep.dft_flux_E_set
    __swig_getmethods__["E"] = _meep.dft_flux_E_get
    if _newclass:
        E = _swig_property(_meep.dft_flux_E_get, _meep.dft_flux_E_set)
    __swig_setmethods__["H"] = _meep.dft_flux_H_set
    __swig_getmethods__["H"] = _meep.dft_flux_H_get
    if _newclass:
        H = _swig_property(_meep.dft_flux_H_get, _meep.dft_flux_H_set)
    __swig_setmethods__["cE"] = _meep.dft_flux_cE_set
    __swig_getmethods__["cE"] = _meep.dft_flux_cE_get
    if _newclass:
        cE = _swig_property(_meep.dft_flux_cE_get, _meep.dft_flux_cE_set)
    __swig_setmethods__["cH"] = _meep.dft_flux_cH_set
    __swig_getmethods__["cH"] = _meep.dft_flux_cH_get
    if _newclass:
        cH = _swig_property(_meep.dft_flux_cH_get, _meep.dft_flux_cH_set)
    __swig_setmethods__["where"] = _meep.dft_flux_where_set
    __swig_getmethods__["where"] = _meep.dft_flux_where_get
    if _newclass:
        where = _swig_property(_meep.dft_flux_where_get, _meep.dft_flux_where_set)
    __swig_setmethods__["normal_direction"] = _meep.dft_flux_normal_direction_set
    __swig_getmethods__["normal_direction"] = _meep.dft_flux_normal_direction_get
    if _newclass:
        normal_direction = _swig_property(_meep.dft_flux_normal_direction_get, _meep.dft_flux_normal_direction_set)
    __swig_destroy__ = _meep.delete_dft_flux
    __del__ = lambda self: None
dft_flux_swigregister = _meep.dft_flux_swigregister
dft_flux_swigregister(dft_flux)

class dft_force(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_force, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_force, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_dft_force(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def force(self):
        return _meep.dft_force_force(self)

    def __isub__(self, fl):
        return _meep.dft_force___isub__(self, fl)

    def save_hdf5(self, *args):
        return _meep.dft_force_save_hdf5(self, *args)

    def load_hdf5(self, *args):
        return _meep.dft_force_load_hdf5(self, *args)

    def scale_dfts(self, scale):
        return _meep.dft_force_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_force_remove(self)
    __swig_setmethods__["freq_min"] = _meep.dft_force_freq_min_set
    __swig_getmethods__["freq_min"] = _meep.dft_force_freq_min_get
    if _newclass:
        freq_min = _swig_property(_meep.dft_force_freq_min_get, _meep.dft_force_freq_min_set)
    __swig_setmethods__["dfreq"] = _meep.dft_force_dfreq_set
    __swig_getmethods__["dfreq"] = _meep.dft_force_dfreq_get
    if _newclass:
        dfreq = _swig_property(_meep.dft_force_dfreq_get, _meep.dft_force_dfreq_set)
    __swig_setmethods__["Nfreq"] = _meep.dft_force_Nfreq_set
    __swig_getmethods__["Nfreq"] = _meep.dft_force_Nfreq_get
    if _newclass:
        Nfreq = _swig_property(_meep.dft_force_Nfreq_get, _meep.dft_force_Nfreq_set)
    __swig_setmethods__["offdiag1"] = _meep.dft_force_offdiag1_set
    __swig_getmethods__["offdiag1"] = _meep.dft_force_offdiag1_get
    if _newclass:
        offdiag1 = _swig_property(_meep.dft_force_offdiag1_get, _meep.dft_force_offdiag1_set)
    __swig_setmethods__["offdiag2"] = _meep.dft_force_offdiag2_set
    __swig_getmethods__["offdiag2"] = _meep.dft_force_offdiag2_get
    if _newclass:
        offdiag2 = _swig_property(_meep.dft_force_offdiag2_get, _meep.dft_force_offdiag2_set)
    __swig_setmethods__["diag"] = _meep.dft_force_diag_set
    __swig_getmethods__["diag"] = _meep.dft_force_diag_get
    if _newclass:
        diag = _swig_property(_meep.dft_force_diag_get, _meep.dft_force_diag_set)
    __swig_setmethods__["where"] = _meep.dft_force_where_set
    __swig_getmethods__["where"] = _meep.dft_force_where_get
    if _newclass:
        where = _swig_property(_meep.dft_force_where_get, _meep.dft_force_where_set)
    __swig_destroy__ = _meep.delete_dft_force
    __del__ = lambda self: None
dft_force_swigregister = _meep.dft_force_swigregister
dft_force_swigregister(dft_force)

class dft_near2far(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_near2far, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_near2far, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_dft_near2far(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def farfield(self, x):
        return _meep.dft_near2far_farfield(self, x)

    def farfield_lowlevel(self, F, x):
        return _meep.dft_near2far_farfield_lowlevel(self, F, x)

    def save_farfields(self, fname, prefix, where, resolution):
        return _meep.dft_near2far_save_farfields(self, fname, prefix, where, resolution)

    def __isub__(self, fl):
        return _meep.dft_near2far___isub__(self, fl)

    def save_hdf5(self, *args):
        return _meep.dft_near2far_save_hdf5(self, *args)

    def load_hdf5(self, *args):
        return _meep.dft_near2far_load_hdf5(self, *args)

    def scale_dfts(self, scale):
        return _meep.dft_near2far_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_near2far_remove(self)
    __swig_setmethods__["freq_min"] = _meep.dft_near2far_freq_min_set
    __swig_getmethods__["freq_min"] = _meep.dft_near2far_freq_min_get
    if _newclass:
        freq_min = _swig_property(_meep.dft_near2far_freq_min_get, _meep.dft_near2far_freq_min_set)
    __swig_setmethods__["dfreq"] = _meep.dft_near2far_dfreq_set
    __swig_getmethods__["dfreq"] = _meep.dft_near2far_dfreq_get
    if _newclass:
        dfreq = _swig_property(_meep.dft_near2far_dfreq_get, _meep.dft_near2far_dfreq_set)
    __swig_setmethods__["Nfreq"] = _meep.dft_near2far_Nfreq_set
    __swig_getmethods__["Nfreq"] = _meep.dft_near2far_Nfreq_get
    if _newclass:
        Nfreq = _swig_property(_meep.dft_near2far_Nfreq_get, _meep.dft_near2far_Nfreq_set)
    __swig_setmethods__["F"] = _meep.dft_near2far_F_set
    __swig_getmethods__["F"] = _meep.dft_near2far_F_get
    if _newclass:
        F = _swig_property(_meep.dft_near2far_F_get, _meep.dft_near2far_F_set)
    __swig_setmethods__["eps"] = _meep.dft_near2far_eps_set
    __swig_getmethods__["eps"] = _meep.dft_near2far_eps_get
    if _newclass:
        eps = _swig_property(_meep.dft_near2far_eps_get, _meep.dft_near2far_eps_set)
    __swig_setmethods__["mu"] = _meep.dft_near2far_mu_set
    __swig_getmethods__["mu"] = _meep.dft_near2far_mu_get
    if _newclass:
        mu = _swig_property(_meep.dft_near2far_mu_get, _meep.dft_near2far_mu_set)
    __swig_setmethods__["where"] = _meep.dft_near2far_where_set
    __swig_getmethods__["where"] = _meep.dft_near2far_where_get
    if _newclass:
        where = _swig_property(_meep.dft_near2far_where_get, _meep.dft_near2far_where_set)
    __swig_destroy__ = _meep.delete_dft_near2far
    __del__ = lambda self: None
dft_near2far_swigregister = _meep.dft_near2far_swigregister
dft_near2far_swigregister(dft_near2far)

class dft_ldos(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_ldos, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_ldos, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _meep.delete_dft_ldos
    __del__ = lambda self: None

    def update(self, f):
        return _meep.dft_ldos_update(self, f)

    def ldos(self):
        return _meep.dft_ldos_ldos(self)

    def F(self):
        return _meep.dft_ldos_F(self)

    def J(self):
        return _meep.dft_ldos_J(self)
    __swig_setmethods__["omega_min"] = _meep.dft_ldos_omega_min_set
    __swig_getmethods__["omega_min"] = _meep.dft_ldos_omega_min_get
    if _newclass:
        omega_min = _swig_property(_meep.dft_ldos_omega_min_get, _meep.dft_ldos_omega_min_set)
    __swig_setmethods__["domega"] = _meep.dft_ldos_domega_set
    __swig_getmethods__["domega"] = _meep.dft_ldos_domega_get
    if _newclass:
        domega = _swig_property(_meep.dft_ldos_domega_get, _meep.dft_ldos_domega_set)
    __swig_setmethods__["Nomega"] = _meep.dft_ldos_Nomega_set
    __swig_getmethods__["Nomega"] = _meep.dft_ldos_Nomega_get
    if _newclass:
        Nomega = _swig_property(_meep.dft_ldos_Nomega_get, _meep.dft_ldos_Nomega_set)
dft_ldos_swigregister = _meep.dft_ldos_swigregister
dft_ldos_swigregister(dft_ldos)

def _dft_ldos(freq_min, freq_max, Nfreq):
    val = _meep.new__dft_ldos(freq_min, freq_max, Nfreq)
    return val

class dft_fields(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_fields, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_fields, name)
    __repr__ = _swig_repr

    def __init__(self, chunks, freq_min, freq_max, Nfreq, where):
        this = _meep.new_dft_fields(chunks, freq_min, freq_max, Nfreq, where)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def scale_dfts(self, scale):
        return _meep.dft_fields_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_fields_remove(self)
    __swig_setmethods__["freq_min"] = _meep.dft_fields_freq_min_set
    __swig_getmethods__["freq_min"] = _meep.dft_fields_freq_min_get
    if _newclass:
        freq_min = _swig_property(_meep.dft_fields_freq_min_get, _meep.dft_fields_freq_min_set)
    __swig_setmethods__["dfreq"] = _meep.dft_fields_dfreq_set
    __swig_getmethods__["dfreq"] = _meep.dft_fields_dfreq_get
    if _newclass:
        dfreq = _swig_property(_meep.dft_fields_dfreq_get, _meep.dft_fields_dfreq_set)
    __swig_setmethods__["Nfreq"] = _meep.dft_fields_Nfreq_set
    __swig_getmethods__["Nfreq"] = _meep.dft_fields_Nfreq_get
    if _newclass:
        Nfreq = _swig_property(_meep.dft_fields_Nfreq_get, _meep.dft_fields_Nfreq_set)
    __swig_setmethods__["chunks"] = _meep.dft_fields_chunks_set
    __swig_getmethods__["chunks"] = _meep.dft_fields_chunks_get
    if _newclass:
        chunks = _swig_property(_meep.dft_fields_chunks_get, _meep.dft_fields_chunks_set)
    __swig_setmethods__["where"] = _meep.dft_fields_where_set
    __swig_getmethods__["where"] = _meep.dft_fields_where_get
    if _newclass:
        where = _swig_property(_meep.dft_fields_where_get, _meep.dft_fields_where_set)
    __swig_destroy__ = _meep.delete_dft_fields
    __del__ = lambda self: None
dft_fields_swigregister = _meep.dft_fields_swigregister
dft_fields_swigregister(dft_fields)

Incoming = _meep.Incoming
Outgoing = _meep.Outgoing
CONNECT_PHASE = _meep.CONNECT_PHASE
CONNECT_NEGATE = _meep.CONNECT_NEGATE
CONNECT_COPY = _meep.CONNECT_COPY
class polarization_state(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, polarization_state, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, polarization_state, name)
    __repr__ = _swig_repr
    __swig_setmethods__["data"] = _meep.polarization_state_data_set
    __swig_getmethods__["data"] = _meep.polarization_state_data_get
    if _newclass:
        data = _swig_property(_meep.polarization_state_data_get, _meep.polarization_state_data_set)
    __swig_setmethods__["s"] = _meep.polarization_state_s_set
    __swig_getmethods__["s"] = _meep.polarization_state_s_get
    if _newclass:
        s = _swig_property(_meep.polarization_state_s_get, _meep.polarization_state_s_set)
    __swig_setmethods__["next"] = _meep.polarization_state_next_set
    __swig_getmethods__["next"] = _meep.polarization_state_next_get
    if _newclass:
        next = _swig_property(_meep.polarization_state_next_get, _meep.polarization_state_next_set)

    def __init__(self):
        this = _meep.new_polarization_state()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_polarization_state
    __del__ = lambda self: None
polarization_state_swigregister = _meep.polarization_state_swigregister
polarization_state_swigregister(polarization_state)

class fields_chunk(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fields_chunk, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fields_chunk, name)
    __repr__ = _swig_repr
    __swig_setmethods__["f"] = _meep.fields_chunk_f_set
    __swig_getmethods__["f"] = _meep.fields_chunk_f_get
    if _newclass:
        f = _swig_property(_meep.fields_chunk_f_get, _meep.fields_chunk_f_set)
    __swig_setmethods__["f_u"] = _meep.fields_chunk_f_u_set
    __swig_getmethods__["f_u"] = _meep.fields_chunk_f_u_get
    if _newclass:
        f_u = _swig_property(_meep.fields_chunk_f_u_get, _meep.fields_chunk_f_u_set)
    __swig_setmethods__["f_w"] = _meep.fields_chunk_f_w_set
    __swig_getmethods__["f_w"] = _meep.fields_chunk_f_w_get
    if _newclass:
        f_w = _swig_property(_meep.fields_chunk_f_w_get, _meep.fields_chunk_f_w_set)
    __swig_setmethods__["f_cond"] = _meep.fields_chunk_f_cond_set
    __swig_getmethods__["f_cond"] = _meep.fields_chunk_f_cond_get
    if _newclass:
        f_cond = _swig_property(_meep.fields_chunk_f_cond_get, _meep.fields_chunk_f_cond_set)
    __swig_setmethods__["f_backup"] = _meep.fields_chunk_f_backup_set
    __swig_getmethods__["f_backup"] = _meep.fields_chunk_f_backup_get
    if _newclass:
        f_backup = _swig_property(_meep.fields_chunk_f_backup_get, _meep.fields_chunk_f_backup_set)
    __swig_setmethods__["f_u_backup"] = _meep.fields_chunk_f_u_backup_set
    __swig_getmethods__["f_u_backup"] = _meep.fields_chunk_f_u_backup_get
    if _newclass:
        f_u_backup = _swig_property(_meep.fields_chunk_f_u_backup_get, _meep.fields_chunk_f_u_backup_set)
    __swig_setmethods__["f_w_backup"] = _meep.fields_chunk_f_w_backup_set
    __swig_getmethods__["f_w_backup"] = _meep.fields_chunk_f_w_backup_get
    if _newclass:
        f_w_backup = _swig_property(_meep.fields_chunk_f_w_backup_get, _meep.fields_chunk_f_w_backup_set)
    __swig_setmethods__["f_cond_backup"] = _meep.fields_chunk_f_cond_backup_set
    __swig_getmethods__["f_cond_backup"] = _meep.fields_chunk_f_cond_backup_get
    if _newclass:
        f_cond_backup = _swig_property(_meep.fields_chunk_f_cond_backup_get, _meep.fields_chunk_f_cond_backup_set)
    __swig_setmethods__["f_w_prev"] = _meep.fields_chunk_f_w_prev_set
    __swig_getmethods__["f_w_prev"] = _meep.fields_chunk_f_w_prev_get
    if _newclass:
        f_w_prev = _swig_property(_meep.fields_chunk_f_w_prev_get, _meep.fields_chunk_f_w_prev_set)
    __swig_setmethods__["f_minus_p"] = _meep.fields_chunk_f_minus_p_set
    __swig_getmethods__["f_minus_p"] = _meep.fields_chunk_f_minus_p_get
    if _newclass:
        f_minus_p = _swig_property(_meep.fields_chunk_f_minus_p_get, _meep.fields_chunk_f_minus_p_set)
    __swig_setmethods__["f_rderiv_int"] = _meep.fields_chunk_f_rderiv_int_set
    __swig_getmethods__["f_rderiv_int"] = _meep.fields_chunk_f_rderiv_int_get
    if _newclass:
        f_rderiv_int = _swig_property(_meep.fields_chunk_f_rderiv_int_get, _meep.fields_chunk_f_rderiv_int_set)
    __swig_setmethods__["dft_chunks"] = _meep.fields_chunk_dft_chunks_set
    __swig_getmethods__["dft_chunks"] = _meep.fields_chunk_dft_chunks_get
    if _newclass:
        dft_chunks = _swig_property(_meep.fields_chunk_dft_chunks_get, _meep.fields_chunk_dft_chunks_set)
    __swig_setmethods__["zeroes"] = _meep.fields_chunk_zeroes_set
    __swig_getmethods__["zeroes"] = _meep.fields_chunk_zeroes_get
    if _newclass:
        zeroes = _swig_property(_meep.fields_chunk_zeroes_get, _meep.fields_chunk_zeroes_set)
    __swig_setmethods__["num_zeroes"] = _meep.fields_chunk_num_zeroes_set
    __swig_getmethods__["num_zeroes"] = _meep.fields_chunk_num_zeroes_get
    if _newclass:
        num_zeroes = _swig_property(_meep.fields_chunk_num_zeroes_get, _meep.fields_chunk_num_zeroes_set)
    __swig_getmethods__["connections"] = _meep.fields_chunk_connections_get
    if _newclass:
        connections = _swig_property(_meep.fields_chunk_connections_get)
    __swig_getmethods__["num_connections"] = _meep.fields_chunk_num_connections_get
    if _newclass:
        num_connections = _swig_property(_meep.fields_chunk_num_connections_get)
    __swig_setmethods__["connection_phases"] = _meep.fields_chunk_connection_phases_set
    __swig_getmethods__["connection_phases"] = _meep.fields_chunk_connection_phases_get
    if _newclass:
        connection_phases = _swig_property(_meep.fields_chunk_connection_phases_get, _meep.fields_chunk_connection_phases_set)
    __swig_setmethods__["npol"] = _meep.fields_chunk_npol_set
    __swig_getmethods__["npol"] = _meep.fields_chunk_npol_get
    if _newclass:
        npol = _swig_property(_meep.fields_chunk_npol_get, _meep.fields_chunk_npol_set)
    __swig_setmethods__["pol"] = _meep.fields_chunk_pol_set
    __swig_getmethods__["pol"] = _meep.fields_chunk_pol_get
    if _newclass:
        pol = _swig_property(_meep.fields_chunk_pol_get, _meep.fields_chunk_pol_set)
    __swig_setmethods__["a"] = _meep.fields_chunk_a_set
    __swig_getmethods__["a"] = _meep.fields_chunk_a_get
    if _newclass:
        a = _swig_property(_meep.fields_chunk_a_get, _meep.fields_chunk_a_set)
    __swig_setmethods__["Courant"] = _meep.fields_chunk_Courant_set
    __swig_getmethods__["Courant"] = _meep.fields_chunk_Courant_get
    if _newclass:
        Courant = _swig_property(_meep.fields_chunk_Courant_get, _meep.fields_chunk_Courant_set)
    __swig_setmethods__["dt"] = _meep.fields_chunk_dt_set
    __swig_getmethods__["dt"] = _meep.fields_chunk_dt_get
    if _newclass:
        dt = _swig_property(_meep.fields_chunk_dt_get, _meep.fields_chunk_dt_set)
    __swig_setmethods__["gv"] = _meep.fields_chunk_gv_set
    __swig_getmethods__["gv"] = _meep.fields_chunk_gv_get
    if _newclass:
        gv = _swig_property(_meep.fields_chunk_gv_get, _meep.fields_chunk_gv_set)
    __swig_setmethods__["v"] = _meep.fields_chunk_v_set
    __swig_getmethods__["v"] = _meep.fields_chunk_v_get
    if _newclass:
        v = _swig_property(_meep.fields_chunk_v_get, _meep.fields_chunk_v_set)
    __swig_setmethods__["m"] = _meep.fields_chunk_m_set
    __swig_getmethods__["m"] = _meep.fields_chunk_m_get
    if _newclass:
        m = _swig_property(_meep.fields_chunk_m_get, _meep.fields_chunk_m_set)
    __swig_setmethods__["zero_fields_near_cylorigin"] = _meep.fields_chunk_zero_fields_near_cylorigin_set
    __swig_getmethods__["zero_fields_near_cylorigin"] = _meep.fields_chunk_zero_fields_near_cylorigin_get
    if _newclass:
        zero_fields_near_cylorigin = _swig_property(_meep.fields_chunk_zero_fields_near_cylorigin_get, _meep.fields_chunk_zero_fields_near_cylorigin_set)
    __swig_setmethods__["beta"] = _meep.fields_chunk_beta_set
    __swig_getmethods__["beta"] = _meep.fields_chunk_beta_get
    if _newclass:
        beta = _swig_property(_meep.fields_chunk_beta_get, _meep.fields_chunk_beta_set)
    __swig_setmethods__["is_real"] = _meep.fields_chunk_is_real_set
    __swig_getmethods__["is_real"] = _meep.fields_chunk_is_real_get
    if _newclass:
        is_real = _swig_property(_meep.fields_chunk_is_real_get, _meep.fields_chunk_is_real_set)
    __swig_setmethods__["sources"] = _meep.fields_chunk_sources_set
    __swig_getmethods__["sources"] = _meep.fields_chunk_sources_get
    if _newclass:
        sources = _swig_property(_meep.fields_chunk_sources_get, _meep.fields_chunk_sources_set)
    __swig_setmethods__["new_s"] = _meep.fields_chunk_new_s_set
    __swig_getmethods__["new_s"] = _meep.fields_chunk_new_s_get
    if _newclass:
        new_s = _swig_property(_meep.fields_chunk_new_s_get, _meep.fields_chunk_new_s_set)
    __swig_setmethods__["s"] = _meep.fields_chunk_s_set
    __swig_getmethods__["s"] = _meep.fields_chunk_s_get
    if _newclass:
        s = _swig_property(_meep.fields_chunk_s_get, _meep.fields_chunk_s_set)
    __swig_setmethods__["outdir"] = _meep.fields_chunk_outdir_set
    __swig_getmethods__["outdir"] = _meep.fields_chunk_outdir_get
    if _newclass:
        outdir = _swig_property(_meep.fields_chunk_outdir_get, _meep.fields_chunk_outdir_set)

    def __init__(self, *args):
        this = _meep.new_fields_chunk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_fields_chunk
    __del__ = lambda self: None

    def peek_field(self, arg2, arg3):
        return _meep.fields_chunk_peek_field(self, arg2, arg3)

    def use_real_fields(self):
        return _meep.fields_chunk_use_real_fields(self)

    def have_component(self, c, is_complex=False):
        return _meep.fields_chunk_have_component(self, c, is_complex)

    def last_source_time(self):
        return _meep.fields_chunk_last_source_time(self)

    def get_field_gv(self, arg2):
        return _meep.fields_chunk_get_field_gv(self, arg2)

    def get_field(self, *args):
        return _meep.fields_chunk_get_field(self, *args)

    def get_chi1inv(self, arg2, arg3, iloc):
        return _meep.fields_chunk_get_chi1inv(self, arg2, arg3, iloc)

    def backup_component(self, c):
        return _meep.fields_chunk_backup_component(self, c)

    def average_with_backup(self, c):
        return _meep.fields_chunk_average_with_backup(self, c)

    def restore_component(self, c):
        return _meep.fields_chunk_restore_component(self, c)

    def set_output_directory(self, name):
        return _meep.fields_chunk_set_output_directory(self, name)

    def verbose(self, gv=1):
        return _meep.fields_chunk_verbose(self, gv)

    def count_volume(self, arg2):
        return _meep.fields_chunk_count_volume(self, arg2)

    def n_proc(self):
        return _meep.fields_chunk_n_proc(self)

    def is_mine(self):
        return _meep.fields_chunk_is_mine(self)

    def zero_metal(self, arg2):
        return _meep.fields_chunk_zero_metal(self, arg2)

    def needs_W_notowned(self, c):
        return _meep.fields_chunk_needs_W_notowned(self, c)

    def remove_sources(self):
        return _meep.fields_chunk_remove_sources(self)

    def remove_susceptibilities(self, shared_chunks):
        return _meep.fields_chunk_remove_susceptibilities(self, shared_chunks)

    def zero_fields(self):
        return _meep.fields_chunk_zero_fields(self)

    def needs_W_prev(self, c):
        return _meep.fields_chunk_needs_W_prev(self, c)

    def update_eh(self, ft, skip_w_components=False):
        return _meep.fields_chunk_update_eh(self, ft, skip_w_components)

    def alloc_f(self, c):
        return _meep.fields_chunk_alloc_f(self, c)

    def figure_out_step_plan(self):
        return _meep.fields_chunk_figure_out_step_plan(self)

    def set_solve_cw_omega(self, omega):
        return _meep.fields_chunk_set_solve_cw_omega(self, omega)

    def unset_solve_cw_omega(self):
        return _meep.fields_chunk_unset_solve_cw_omega(self)
fields_chunk_swigregister = _meep.fields_chunk_swigregister
fields_chunk_swigregister(fields_chunk)

Periodic = _meep.Periodic
Metallic = _meep.Metallic
Magnetic = _meep.Magnetic
Meep_None = _meep.Meep_None
Connecting = _meep.Connecting
Stepping = _meep.Stepping
Boundaries = _meep.Boundaries
MpiTime = _meep.MpiTime
FieldOutput = _meep.FieldOutput
FourierTransforming = _meep.FourierTransforming
Other = _meep.Other

def derived_component_func(c, gv, nfields, cs):
    return _meep.derived_component_func(c, gv, nfields, cs)
derived_component_func = _meep.derived_component_func
class fields(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fields, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fields, name)
    __repr__ = _swig_repr
    __swig_setmethods__["num_chunks"] = _meep.fields_num_chunks_set
    __swig_getmethods__["num_chunks"] = _meep.fields_num_chunks_get
    if _newclass:
        num_chunks = _swig_property(_meep.fields_num_chunks_get, _meep.fields_num_chunks_set)
    __swig_setmethods__["shared_chunks"] = _meep.fields_shared_chunks_set
    __swig_getmethods__["shared_chunks"] = _meep.fields_shared_chunks_get
    if _newclass:
        shared_chunks = _swig_property(_meep.fields_shared_chunks_get, _meep.fields_shared_chunks_set)
    __swig_setmethods__["chunks"] = _meep.fields_chunks_set
    __swig_getmethods__["chunks"] = _meep.fields_chunks_get
    if _newclass:
        chunks = _swig_property(_meep.fields_chunks_get, _meep.fields_chunks_set)
    __swig_setmethods__["sources"] = _meep.fields_sources_set
    __swig_getmethods__["sources"] = _meep.fields_sources_get
    if _newclass:
        sources = _swig_property(_meep.fields_sources_get, _meep.fields_sources_set)
    __swig_setmethods__["fluxes"] = _meep.fields_fluxes_set
    __swig_getmethods__["fluxes"] = _meep.fields_fluxes_get
    if _newclass:
        fluxes = _swig_property(_meep.fields_fluxes_get, _meep.fields_fluxes_set)
    __swig_setmethods__["S"] = _meep.fields_S_set
    __swig_getmethods__["S"] = _meep.fields_S_get
    if _newclass:
        S = _swig_property(_meep.fields_S_get, _meep.fields_S_set)
    __swig_setmethods__["comm_blocks"] = _meep.fields_comm_blocks_set
    __swig_getmethods__["comm_blocks"] = _meep.fields_comm_blocks_get
    if _newclass:
        comm_blocks = _swig_property(_meep.fields_comm_blocks_get, _meep.fields_comm_blocks_set)
    __swig_setmethods__["comm_sizes"] = _meep.fields_comm_sizes_set
    __swig_getmethods__["comm_sizes"] = _meep.fields_comm_sizes_get
    if _newclass:
        comm_sizes = _swig_property(_meep.fields_comm_sizes_get, _meep.fields_comm_sizes_set)

    def comm_size_tot(self, f, pair):
        return _meep.fields_comm_size_tot(self, f, pair)
    __swig_setmethods__["a"] = _meep.fields_a_set
    __swig_getmethods__["a"] = _meep.fields_a_get
    if _newclass:
        a = _swig_property(_meep.fields_a_get, _meep.fields_a_set)
    __swig_setmethods__["dt"] = _meep.fields_dt_set
    __swig_getmethods__["dt"] = _meep.fields_dt_get
    if _newclass:
        dt = _swig_property(_meep.fields_dt_get, _meep.fields_dt_set)
    __swig_setmethods__["gv"] = _meep.fields_gv_set
    __swig_getmethods__["gv"] = _meep.fields_gv_get
    if _newclass:
        gv = _swig_property(_meep.fields_gv_get, _meep.fields_gv_set)
    __swig_setmethods__["user_volume"] = _meep.fields_user_volume_set
    __swig_getmethods__["user_volume"] = _meep.fields_user_volume_get
    if _newclass:
        user_volume = _swig_property(_meep.fields_user_volume_get, _meep.fields_user_volume_set)
    __swig_setmethods__["v"] = _meep.fields_v_set
    __swig_getmethods__["v"] = _meep.fields_v_get
    if _newclass:
        v = _swig_property(_meep.fields_v_get, _meep.fields_v_set)
    __swig_setmethods__["m"] = _meep.fields_m_set
    __swig_getmethods__["m"] = _meep.fields_m_get
    if _newclass:
        m = _swig_property(_meep.fields_m_get, _meep.fields_m_set)
    __swig_setmethods__["beta"] = _meep.fields_beta_set
    __swig_getmethods__["beta"] = _meep.fields_beta_get
    if _newclass:
        beta = _swig_property(_meep.fields_beta_get, _meep.fields_beta_set)
    __swig_setmethods__["t"] = _meep.fields_t_set
    __swig_getmethods__["t"] = _meep.fields_t_get
    if _newclass:
        t = _swig_property(_meep.fields_t_get, _meep.fields_t_set)
    __swig_setmethods__["phasein_time"] = _meep.fields_phasein_time_set
    __swig_getmethods__["phasein_time"] = _meep.fields_phasein_time_get
    if _newclass:
        phasein_time = _swig_property(_meep.fields_phasein_time_get, _meep.fields_phasein_time_set)
    __swig_setmethods__["is_real"] = _meep.fields_is_real_set
    __swig_getmethods__["is_real"] = _meep.fields_is_real_get
    if _newclass:
        is_real = _swig_property(_meep.fields_is_real_get, _meep.fields_is_real_set)
    __swig_setmethods__["k"] = _meep.fields_k_set
    __swig_getmethods__["k"] = _meep.fields_k_get
    if _newclass:
        k = _swig_property(_meep.fields_k_get, _meep.fields_k_set)
    __swig_setmethods__["eikna"] = _meep.fields_eikna_set
    __swig_getmethods__["eikna"] = _meep.fields_eikna_get
    if _newclass:
        eikna = _swig_property(_meep.fields_eikna_get, _meep.fields_eikna_set)
    __swig_setmethods__["coskna"] = _meep.fields_coskna_set
    __swig_getmethods__["coskna"] = _meep.fields_coskna_get
    if _newclass:
        coskna = _swig_property(_meep.fields_coskna_get, _meep.fields_coskna_set)
    __swig_setmethods__["sinkna"] = _meep.fields_sinkna_set
    __swig_getmethods__["sinkna"] = _meep.fields_sinkna_get
    if _newclass:
        sinkna = _swig_property(_meep.fields_sinkna_get, _meep.fields_sinkna_set)
    __swig_setmethods__["boundaries"] = _meep.fields_boundaries_set
    __swig_getmethods__["boundaries"] = _meep.fields_boundaries_get
    if _newclass:
        boundaries = _swig_property(_meep.fields_boundaries_get, _meep.fields_boundaries_set)
    __swig_setmethods__["outdir"] = _meep.fields_outdir_set
    __swig_getmethods__["outdir"] = _meep.fields_outdir_get
    if _newclass:
        outdir = _swig_property(_meep.fields_outdir_get, _meep.fields_outdir_set)
    __swig_setmethods__["components_allocated"] = _meep.fields_components_allocated_set
    __swig_getmethods__["components_allocated"] = _meep.fields_components_allocated_get
    if _newclass:
        components_allocated = _swig_property(_meep.fields_components_allocated_get, _meep.fields_components_allocated_set)

    def __init__(self, *args):
        this = _meep.new_fields(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_fields
    __del__ = lambda self: None

    def equal_layout(self, f):
        return _meep.fields_equal_layout(self, f)

    def use_real_fields(self):
        return _meep.fields_use_real_fields(self)

    def zero_fields(self):
        return _meep.fields_zero_fields(self)

    def remove_sources(self):
        return _meep.fields_remove_sources(self)

    def remove_susceptibilities(self):
        return _meep.fields_remove_susceptibilities(self)

    def remove_fluxes(self):
        return _meep.fields_remove_fluxes(self)

    def reset(self):
        return _meep.fields_reset(self)

    def time_spent_on(self, arg2):
        return _meep.fields_time_spent_on(self, arg2)

    def print_times(self):
        return _meep.fields_print_times(self)

    def set_boundary(self, arg2, arg3, arg4):
        return _meep.fields_set_boundary(self, arg2, arg3, arg4)

    def use_bloch(self, *args):
        return _meep.fields_use_bloch(self, *args)

    def lattice_vector(self, arg2):
        return _meep.fields_lattice_vector(self, arg2)

    def update_eh(self, ft, skip_w_components=False):
        return _meep.fields_update_eh(self, ft, skip_w_components)

    def total_volume(self):
        return _meep.fields_total_volume(self)

    def output_hdf5(self, *args):
        return _meep.fields_output_hdf5(self, *args)

    def open_h5file(self, *args):
        return _meep.fields_open_h5file(self, *args)

    def h5file_name(self, name, prefix=None, timestamp=False):
        return _meep.fields_h5file_name(self, name, prefix, timestamp)

    def get_array_slice_dimensions(self, where, dims, data=None):
        return _meep.fields_get_array_slice_dimensions(self, where, dims, data)

    def get_array_slice(self, *args):
        return _meep.fields_get_array_slice(self, *args)

    def get_complex_array_slice(self, *args):
        return _meep.fields_get_complex_array_slice(self, *args)

    def do_get_array_slice(self, where, components, fun, rfun, fun_data, vslice):
        return _meep.fields_do_get_array_slice(self, where, components, fun, rfun, fun_data, vslice)
    __swig_setmethods__["last_step_output_wall_time"] = _meep.fields_last_step_output_wall_time_set
    __swig_getmethods__["last_step_output_wall_time"] = _meep.fields_last_step_output_wall_time_get
    if _newclass:
        last_step_output_wall_time = _swig_property(_meep.fields_last_step_output_wall_time_get, _meep.fields_last_step_output_wall_time_set)
    __swig_setmethods__["last_step_output_t"] = _meep.fields_last_step_output_t_set
    __swig_getmethods__["last_step_output_t"] = _meep.fields_last_step_output_t_get
    if _newclass:
        last_step_output_t = _swig_property(_meep.fields_last_step_output_t_get, _meep.fields_last_step_output_t_set)

    def step(self):
        return _meep.fields_step(self)

    def round_time(self):
        return _meep.fields_round_time(self)

    def time(self):
        return _meep.fields_time(self)

    def solve_cw(self, *args):
        return _meep.fields_solve_cw(self, *args)

    def last_source_time(self):
        return _meep.fields_last_source_time(self)

    def add_point_source(self, *args):
        return _meep.fields_add_point_source(self, *args)

    def add_volume_source(self, *args):
        return _meep.fields_add_volume_source(self, *args)

    def require_component(self, c):
        return _meep.fields_require_component(self, c)

    def get_eigenmode(self, omega_src, d, where, eig_vol, band_num, kpoint, match_frequency, parity, resolution, eigensolver_tol, verbose=False):
        return _meep.fields_get_eigenmode(self, omega_src, d, where, eig_vol, band_num, kpoint, match_frequency, parity, resolution, eigensolver_tol, verbose)

    def add_eigenmode_source(self, *args):
        return _meep.fields_add_eigenmode_source(self, *args)

    def get_eigenmode_coefficients(self, *args):
        return _meep.fields_get_eigenmode_coefficients(self, *args)

    def initialize_field(self, arg2, f):
        return _meep.fields_initialize_field(self, arg2, f)

    def initialize_with_nth_te(self, n):
        return _meep.fields_initialize_with_nth_te(self, n)

    def initialize_with_nth_tm(self, n):
        return _meep.fields_initialize_with_nth_tm(self, n)

    def initialize_with_n_te(self, ntot):
        return _meep.fields_initialize_with_n_te(self, ntot)

    def initialize_with_n_tm(self, ntot):
        return _meep.fields_initialize_with_n_tm(self, ntot)

    def phase_in_material(self, s, time):
        return _meep.fields_phase_in_material(self, s, time)

    def is_phasing(self):
        return _meep.fields_is_phasing(self)

    def loop_in_chunks(self, *args):
        return _meep.fields_loop_in_chunks(self, *args)

    def integrate(self, *args):
        return _meep.fields_integrate(self, *args)

    def integrate2(self, *args):
        return _meep.fields_integrate2(self, *args)

    def max_abs(self, *args):
        return _meep.fields_max_abs(self, *args)

    def add_dft_pt(self, c, where, freq_min, freq_max, Nfreq):
        return _meep.fields_add_dft_pt(self, c, where, freq_min, freq_max, Nfreq)

    def add_dft(self, *args):
        return _meep.fields_add_dft(self, *args)

    def update_dfts(self):
        return _meep.fields_update_dfts(self)

    def add_dft_flux_box(self, where, freq_min, freq_max, Nfreq):
        return _meep.fields_add_dft_flux_box(self, where, freq_min, freq_max, Nfreq)

    def add_dft_flux_plane(self, where, freq_min, freq_max, Nfreq):
        return _meep.fields_add_dft_flux_plane(self, where, freq_min, freq_max, Nfreq)

    def add_dft_flux(self, *args):
        return _meep.fields_add_dft_flux(self, *args)

    def add_dft_fields(self, components, where, freq_min, freq_max, Nfreq):
        return _meep.fields_add_dft_fields(self, components, where, freq_min, freq_max, Nfreq)

    def process_dft_component(self, *args):
        return _meep.fields_process_dft_component(self, *args)

    def output_dft_components(self, chunklists, num_chunklists, dft_volume, HDF5FileName):
        return _meep.fields_output_dft_components(self, chunklists, num_chunklists, dft_volume, HDF5FileName)

    def output_dft(self, *args):
        return _meep.fields_output_dft(self, *args)

    def output_mode_fields(self, mode_data, flux, HDF5FileName):
        return _meep.fields_output_mode_fields(self, mode_data, flux, HDF5FileName)

    def get_dft_array(self, *args):
        return _meep.fields_get_dft_array(self, *args)

    def get_overlap(self, mode1_data, mode2_data, flux, num_freq, overlaps):
        return _meep.fields_get_overlap(self, mode1_data, mode2_data, flux, num_freq, overlaps)

    def get_mode_flux_overlap(self, mode_data, flux, num_freq, overlaps):
        return _meep.fields_get_mode_flux_overlap(self, mode_data, flux, num_freq, overlaps)

    def get_mode_mode_overlap(self, mode1_data, mode2_data, flux, overlaps):
        return _meep.fields_get_mode_mode_overlap(self, mode1_data, mode2_data, flux, overlaps)

    def add_dft_force(self, where, freq_min, freq_max, Nfreq):
        return _meep.fields_add_dft_force(self, where, freq_min, freq_max, Nfreq)

    def add_dft_near2far(self, where, freq_min, freq_max, Nfreq):
        return _meep.fields_add_dft_near2far(self, where, freq_min, freq_max, Nfreq)

    def get_inveps(self, c, d, loc):
        return _meep.fields_get_inveps(self, c, d, loc)

    def get_eps(self, loc):
        return _meep.fields_get_eps(self, loc)

    def get_mu(self, loc):
        return _meep.fields_get_mu(self, loc)

    def get_point(self, p, arg3):
        return _meep.fields_get_point(self, p, arg3)

    def get_new_point(self, arg2, p=None):
        return _meep.fields_get_new_point(self, arg2, p)

    def get_field_from_comp(self, c, loc):
        return _meep.fields_get_field_from_comp(self, c, loc)

    def synchronize_magnetic_fields(self):
        return _meep.fields_synchronize_magnetic_fields(self)

    def restore_magnetic_fields(self):
        return _meep.fields_restore_magnetic_fields(self)

    def energy_in_box(self, arg2):
        return _meep.fields_energy_in_box(self, arg2)

    def electric_energy_in_box(self, arg2):
        return _meep.fields_electric_energy_in_box(self, arg2)

    def magnetic_energy_in_box(self, arg2):
        return _meep.fields_magnetic_energy_in_box(self, arg2)

    def thermo_energy_in_box(self, arg2):
        return _meep.fields_thermo_energy_in_box(self, arg2)

    def total_energy(self):
        return _meep.fields_total_energy(self)

    def field_energy_in_box(self, *args):
        return _meep.fields_field_energy_in_box(self, *args)

    def field_energy(self):
        return _meep.fields_field_energy(self)

    def flux_in_box_wrongH(self, d, arg3):
        return _meep.fields_flux_in_box_wrongH(self, d, arg3)

    def flux_in_box(self, d, arg3):
        return _meep.fields_flux_in_box(self, d, arg3)

    def add_flux_vol(self, d, where):
        return _meep.fields_add_flux_vol(self, d, where)

    def add_flux_plane(self, *args):
        return _meep.fields_add_flux_plane(self, *args)

    def electric_energy_max_in_box(self, where):
        return _meep.fields_electric_energy_max_in_box(self, where)

    def modal_volume_in_box(self, where):
        return _meep.fields_modal_volume_in_box(self, where)

    def electric_sqr_weighted_integral(self, deps, where):
        return _meep.fields_electric_sqr_weighted_integral(self, deps, where)

    def electric_energy_weighted_integral(self, f, where):
        return _meep.fields_electric_energy_weighted_integral(self, f, where)

    def set_output_directory(self, name):
        return _meep.fields_set_output_directory(self, name)

    def verbose(self, gv=1):
        return _meep.fields_verbose(self, gv)

    def count_volume(self, arg2):
        return _meep.fields_count_volume(self, arg2)

    def have_component(self, arg2):
        return _meep.fields_have_component(self, arg2)

    def max_eps(self):
        return _meep.fields_max_eps(self)

    def step_boundaries(self, arg2):
        return _meep.fields_step_boundaries(self, arg2)

    def nosize_direction(self, d):
        return _meep.fields_nosize_direction(self, d)

    def normal_direction(self, where):
        return _meep.fields_normal_direction(self, where)

    def casimir_stress_dct_integral(self, dforce, dsource, mx, my, mz, ft, where, is_bloch=False):
        return _meep.fields_casimir_stress_dct_integral(self, dforce, dsource, mx, my, mz, ft, where, is_bloch)

    def set_solve_cw_omega(self, omega):
        return _meep.fields_set_solve_cw_omega(self, omega)

    def unset_solve_cw_omega(self):
        return _meep.fields_unset_solve_cw_omega(self)

    def get_field(self, *args):
        return _meep.fields_get_field(self, *args)

    def get_chi1inv(self, *args):
        return _meep.fields_get_chi1inv(self, *args)

    def locate_component_point(self, arg2, arg3, arg4):
        return _meep.fields_locate_component_point(self, arg2, arg3, arg4)
fields_swigregister = _meep.fields_swigregister
fields_swigregister(fields)

class flux_vol(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, flux_vol, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, flux_vol, name)
    __repr__ = _swig_repr

    def __init__(self, f_, d_, where_):
        this = _meep.new_flux_vol(f_, d_, where_)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_flux_vol
    __del__ = lambda self: None

    def update_half(self):
        return _meep.flux_vol_update_half(self)

    def update(self):
        return _meep.flux_vol_update(self)

    def flux(self):
        return _meep.flux_vol_flux(self)
    __swig_setmethods__["next"] = _meep.flux_vol_next_set
    __swig_getmethods__["next"] = _meep.flux_vol_next_get
    if _newclass:
        next = _swig_property(_meep.flux_vol_next_get, _meep.flux_vol_next_set)
flux_vol_swigregister = _meep.flux_vol_swigregister
flux_vol_swigregister(flux_vol)


def make_output_directory(exename, jobname=None):
    return _meep.make_output_directory(exename, jobname)
make_output_directory = _meep.make_output_directory

def trash_output_directory(dirname):
    return _meep.trash_output_directory(dirname)
trash_output_directory = _meep.trash_output_directory

def create_output_file(dirname, fname):
    return _meep.create_output_file(dirname, fname)
create_output_file = _meep.create_output_file

def deal_with_ctrl_c(stop_now=2):
    return _meep.deal_with_ctrl_c(stop_now)
deal_with_ctrl_c = _meep.deal_with_ctrl_c

def do_harminv(data, n, dt, fmin, fmax, maxbands, amps, freq_re, freq_im, errors=None, spectral_density=1.1, Q_thresh=50, rel_err_thresh=1e20, err_thresh=0.01, rel_amp_thresh=-1, amp_thresh=-1):
    return _meep.do_harminv(data, n, dt, fmin, fmax, maxbands, amps, freq_re, freq_im, errors, spectral_density, Q_thresh, rel_err_thresh, err_thresh, rel_amp_thresh, amp_thresh)
do_harminv = _meep.do_harminv

def make_casimir_gfunc(T, dt, sigma, ft, eps_func=None, Tfft=0):
    return _meep.make_casimir_gfunc(T, dt, sigma, ft, eps_func, Tfft)
make_casimir_gfunc = _meep.make_casimir_gfunc

def make_casimir_gfunc_kz(T, dt, sigma, ft):
    return _meep.make_casimir_gfunc_kz(T, dt, sigma, ft)
make_casimir_gfunc_kz = _meep.make_casimir_gfunc_kz

def set_random_seed(seed):
    return _meep.set_random_seed(seed)
set_random_seed = _meep.set_random_seed

def uniform_random(a, b):
    return _meep.uniform_random(a, b)
uniform_random = _meep.uniform_random

def gaussian_random(mean, stddev):
    return _meep.gaussian_random(mean, stddev)
gaussian_random = _meep.gaussian_random

def random_int(a, b):
    return _meep.random_int(a, b)
random_int = _meep.random_int

def BesselJ(m, kr):
    return _meep.BesselJ(m, kr)
BesselJ = _meep.BesselJ

def green2d(EH, x, freq, eps, mu, x0, c0, f0):
    return _meep.green2d(EH, x, freq, eps, mu, x0, c0, f0)
green2d = _meep.green2d

def green3d(EH, x, freq, eps, mu, x0, c0, f0):
    return _meep.green3d(EH, x, freq, eps, mu, x0, c0, f0)
green3d = _meep.green3d

def destroy_eigenmode_data(vedata):
    return _meep.destroy_eigenmode_data(vedata)
destroy_eigenmode_data = _meep.destroy_eigenmode_data

def eigenmode_amplitude(vedata, p, c):
    return _meep.eigenmode_amplitude(vedata, p, c)
eigenmode_amplitude = _meep.eigenmode_amplitude

def get_group_velocity(vedata):
    return _meep.get_group_velocity(vedata)
get_group_velocity = _meep.get_group_velocity

def get_k(vedata):
    return _meep.get_k(vedata)
get_k = _meep.get_k

def wall_time():
    return _meep.wall_time()
wall_time = _meep.wall_time
class initialize(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, initialize, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, initialize, name)
    __repr__ = _swig_repr

    def __init__(self, argc, argv):
        this = _meep.new_initialize(argc, argv)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_initialize
    __del__ = lambda self: None

    def elapsed_time(self):
        return _meep.initialize_elapsed_time(self)
initialize_swigregister = _meep.initialize_swigregister
initialize_swigregister(initialize)


def all_wait():
    return _meep.all_wait()
all_wait = _meep.all_wait

def count_processors():
    return _meep.count_processors()
count_processors = _meep.count_processors

def my_rank():
    return _meep.my_rank()
my_rank = _meep.my_rank

def am_really_master():
    return _meep.am_really_master()
am_really_master = _meep.am_really_master

def am_master():
    return _meep.am_master()
am_master = _meep.am_master

def with_mpi():
    return _meep.with_mpi()
with_mpi = _meep.with_mpi

def send(arg1, to, data, size=1):
    return _meep.send(arg1, to, data, size)
send = _meep.send

def broadcast(*args):
    return _meep.broadcast(*args)
broadcast = _meep.broadcast

def max_to_master(arg1):
    return _meep.max_to_master(arg1)
max_to_master = _meep.max_to_master

def max_to_all(*args):
    return _meep.max_to_all(*args)
max_to_all = _meep.max_to_all

def partial_sum_to_all(*args):
    return _meep.partial_sum_to_all(*args)
partial_sum_to_all = _meep.partial_sum_to_all

def sum_to_all(*args):
    return _meep.sum_to_all(*args)
sum_to_all = _meep.sum_to_all

def sum_to_master(*args):
    return _meep.sum_to_master(*args)
sum_to_master = _meep.sum_to_master

def or_to_all(*args):
    return _meep.or_to_all(*args)
or_to_all = _meep.or_to_all

def and_to_all(*args):
    return _meep.and_to_all(*args)
and_to_all = _meep.and_to_all

def master_printf(fmt):
    return _meep.master_printf(fmt)
master_printf = _meep.master_printf

def debug_printf(fmt):
    return _meep.debug_printf(fmt)
debug_printf = _meep.debug_printf

def master_fprintf(f, fmt):
    return _meep.master_fprintf(f, fmt)
master_fprintf = _meep.master_fprintf

def master_fopen(name, mode):
    return _meep.master_fopen(name, mode)
master_fopen = _meep.master_fopen

def master_fclose(f):
    return _meep.master_fclose(f)
master_fclose = _meep.master_fclose

def begin_critical_section(tag):
    return _meep.begin_critical_section(tag)
begin_critical_section = _meep.begin_critical_section

def end_critical_section(tag):
    return _meep.end_critical_section(tag)
end_critical_section = _meep.end_critical_section

def divide_parallel_processes(numgroups):
    return _meep.divide_parallel_processes(numgroups)
divide_parallel_processes = _meep.divide_parallel_processes

def begin_global_communications():
    return _meep.begin_global_communications()
begin_global_communications = _meep.begin_global_communications

def end_global_communications():
    return _meep.end_global_communications()
end_global_communications = _meep.end_global_communications

def end_divide_parallel():
    return _meep.end_divide_parallel()
end_divide_parallel = _meep.end_divide_parallel

def my_global_rank():
    return _meep.my_global_rank()
my_global_rank = _meep.my_global_rank
CYLINDRICAL = _meep.CYLINDRICAL
X_DIR = _meep.X_DIR
Y_DIR = _meep.Y_DIR
Z_DIR = _meep.Z_DIR
R_DIR = _meep.R_DIR
PHI_DIR = _meep.PHI_DIR
ALL_SIDES = _meep.ALL_SIDES
ALL_DIRECTIONS = _meep.ALL_DIRECTIONS
ENORMOUS = _meep.ENORMOUS
TINY = _meep.TINY
class dft_data(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_data, name)
    __repr__ = _swig_repr
    __swig_setmethods__["num_freqs"] = _meep.dft_data_num_freqs_set
    __swig_getmethods__["num_freqs"] = _meep.dft_data_num_freqs_get
    if _newclass:
        num_freqs = _swig_property(_meep.dft_data_num_freqs_get, _meep.dft_data_num_freqs_set)
    __swig_setmethods__["num_components"] = _meep.dft_data_num_components_set
    __swig_getmethods__["num_components"] = _meep.dft_data_num_components_get
    if _newclass:
        num_components = _swig_property(_meep.dft_data_num_components_get, _meep.dft_data_num_components_set)
    __swig_setmethods__["vols"] = _meep.dft_data_vols_set
    __swig_getmethods__["vols"] = _meep.dft_data_vols_get
    if _newclass:
        vols = _swig_property(_meep.dft_data_vols_get, _meep.dft_data_vols_set)

    def __init__(self, freqs, components, volumes):
        this = _meep.new_dft_data(freqs, components, volumes)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_dft_data
    __del__ = lambda self: None
dft_data_swigregister = _meep.dft_data_swigregister
dft_data_swigregister(dft_data)

class fragment_stats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fragment_stats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fragment_stats, name)
    __repr__ = _swig_repr
    __swig_setmethods__["tol"] = _meep.fragment_stats_tol_set
    __swig_getmethods__["tol"] = _meep.fragment_stats_tol_get
    if _newclass:
        tol = _swig_property(_meep.fragment_stats_tol_get, _meep.fragment_stats_tol_set)
    __swig_setmethods__["maxeval"] = _meep.fragment_stats_maxeval_set
    __swig_getmethods__["maxeval"] = _meep.fragment_stats_maxeval_get
    if _newclass:
        maxeval = _swig_property(_meep.fragment_stats_maxeval_get, _meep.fragment_stats_maxeval_set)
    __swig_setmethods__["resolution"] = _meep.fragment_stats_resolution_set
    __swig_getmethods__["resolution"] = _meep.fragment_stats_resolution_get
    if _newclass:
        resolution = _swig_property(_meep.fragment_stats_resolution_get, _meep.fragment_stats_resolution_set)
    __swig_setmethods__["dims"] = _meep.fragment_stats_dims_set
    __swig_getmethods__["dims"] = _meep.fragment_stats_dims_get
    if _newclass:
        dims = _swig_property(_meep.fragment_stats_dims_get, _meep.fragment_stats_dims_set)
    __swig_setmethods__["num_anisotropic_eps_pixels"] = _meep.fragment_stats_num_anisotropic_eps_pixels_set
    __swig_getmethods__["num_anisotropic_eps_pixels"] = _meep.fragment_stats_num_anisotropic_eps_pixels_get
    if _newclass:
        num_anisotropic_eps_pixels = _swig_property(_meep.fragment_stats_num_anisotropic_eps_pixels_get, _meep.fragment_stats_num_anisotropic_eps_pixels_set)
    __swig_setmethods__["num_anisotropic_mu_pixels"] = _meep.fragment_stats_num_anisotropic_mu_pixels_set
    __swig_getmethods__["num_anisotropic_mu_pixels"] = _meep.fragment_stats_num_anisotropic_mu_pixels_get
    if _newclass:
        num_anisotropic_mu_pixels = _swig_property(_meep.fragment_stats_num_anisotropic_mu_pixels_get, _meep.fragment_stats_num_anisotropic_mu_pixels_set)
    __swig_setmethods__["num_nonlinear_pixels"] = _meep.fragment_stats_num_nonlinear_pixels_set
    __swig_getmethods__["num_nonlinear_pixels"] = _meep.fragment_stats_num_nonlinear_pixels_get
    if _newclass:
        num_nonlinear_pixels = _swig_property(_meep.fragment_stats_num_nonlinear_pixels_get, _meep.fragment_stats_num_nonlinear_pixels_set)
    __swig_setmethods__["num_susceptibility_pixels"] = _meep.fragment_stats_num_susceptibility_pixels_set
    __swig_getmethods__["num_susceptibility_pixels"] = _meep.fragment_stats_num_susceptibility_pixels_get
    if _newclass:
        num_susceptibility_pixels = _swig_property(_meep.fragment_stats_num_susceptibility_pixels_get, _meep.fragment_stats_num_susceptibility_pixels_set)
    __swig_setmethods__["num_nonzero_conductivity_pixels"] = _meep.fragment_stats_num_nonzero_conductivity_pixels_set
    __swig_getmethods__["num_nonzero_conductivity_pixels"] = _meep.fragment_stats_num_nonzero_conductivity_pixels_get
    if _newclass:
        num_nonzero_conductivity_pixels = _swig_property(_meep.fragment_stats_num_nonzero_conductivity_pixels_get, _meep.fragment_stats_num_nonzero_conductivity_pixels_set)
    __swig_setmethods__["num_dft_pixels"] = _meep.fragment_stats_num_dft_pixels_set
    __swig_getmethods__["num_dft_pixels"] = _meep.fragment_stats_num_dft_pixels_get
    if _newclass:
        num_dft_pixels = _swig_property(_meep.fragment_stats_num_dft_pixels_get, _meep.fragment_stats_num_dft_pixels_set)
    __swig_setmethods__["num_pixels_in_box"] = _meep.fragment_stats_num_pixels_in_box_set
    __swig_getmethods__["num_pixels_in_box"] = _meep.fragment_stats_num_pixels_in_box_get
    if _newclass:
        num_pixels_in_box = _swig_property(_meep.fragment_stats_num_pixels_in_box_get, _meep.fragment_stats_num_pixels_in_box_set)
    __swig_setmethods__["box"] = _meep.fragment_stats_box_set
    __swig_getmethods__["box"] = _meep.fragment_stats_box_get
    if _newclass:
        box = _swig_property(_meep.fragment_stats_box_get, _meep.fragment_stats_box_set)

    def __init__(self, *args):
        this = _meep.new_fragment_stats(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def update_stats_from_material(self, mat, pixels):
        return _meep.fragment_stats_update_stats_from_material(self, mat, pixels)

    def compute_stats(self, geom):
        return _meep.fragment_stats_compute_stats(self, geom)

    def count_anisotropic_pixels(self, med, pixels):
        return _meep.fragment_stats_count_anisotropic_pixels(self, med, pixels)

    def count_nonlinear_pixels(self, med, pixels):
        return _meep.fragment_stats_count_nonlinear_pixels(self, med, pixels)

    def count_susceptibility_pixels(self, med, pixels):
        return _meep.fragment_stats_count_susceptibility_pixels(self, med, pixels)

    def count_nonzero_conductivity_pixels(self, med, pixels):
        return _meep.fragment_stats_count_nonzero_conductivity_pixels(self, med, pixels)

    def compute_dft_stats(self, dft_data_list):
        return _meep.fragment_stats_compute_dft_stats(self, dft_data_list)

    def print_stats(self):
        return _meep.fragment_stats_print_stats(self)
    __swig_destroy__ = _meep.delete_fragment_stats
    __del__ = lambda self: None
fragment_stats_swigregister = _meep.fragment_stats_swigregister
fragment_stats_swigregister(fragment_stats)


def compute_fragment_stats(geom, gv, cell_size, cell_center, default_mat, dft_data_list, tol, maxeval, ensure_per, box_size=10):
    return _meep.compute_fragment_stats(geom, gv, cell_size, cell_center, default_mat, dft_data_list, tol, maxeval, ensure_per, box_size)
compute_fragment_stats = _meep.compute_fragment_stats
class absorber(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, absorber, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, absorber, name)
    __repr__ = _swig_repr
    __swig_setmethods__["thickness"] = _meep.absorber_thickness_set
    __swig_getmethods__["thickness"] = _meep.absorber_thickness_get
    if _newclass:
        thickness = _swig_property(_meep.absorber_thickness_get, _meep.absorber_thickness_set)
    __swig_setmethods__["direction"] = _meep.absorber_direction_set
    __swig_getmethods__["direction"] = _meep.absorber_direction_get
    if _newclass:
        direction = _swig_property(_meep.absorber_direction_get, _meep.absorber_direction_set)
    __swig_setmethods__["side"] = _meep.absorber_side_set
    __swig_getmethods__["side"] = _meep.absorber_side_get
    if _newclass:
        side = _swig_property(_meep.absorber_side_get, _meep.absorber_side_set)
    __swig_setmethods__["R_asymptotic"] = _meep.absorber_R_asymptotic_set
    __swig_getmethods__["R_asymptotic"] = _meep.absorber_R_asymptotic_get
    if _newclass:
        R_asymptotic = _swig_property(_meep.absorber_R_asymptotic_get, _meep.absorber_R_asymptotic_set)
    __swig_setmethods__["mean_stretch"] = _meep.absorber_mean_stretch_set
    __swig_getmethods__["mean_stretch"] = _meep.absorber_mean_stretch_get
    if _newclass:
        mean_stretch = _swig_property(_meep.absorber_mean_stretch_get, _meep.absorber_mean_stretch_set)
    __swig_setmethods__["pml_profile"] = _meep.absorber_pml_profile_set
    __swig_getmethods__["pml_profile"] = _meep.absorber_pml_profile_get
    if _newclass:
        pml_profile = _swig_property(_meep.absorber_pml_profile_get, _meep.absorber_pml_profile_set)
    __swig_setmethods__["pml_profile_data"] = _meep.absorber_pml_profile_data_set
    __swig_getmethods__["pml_profile_data"] = _meep.absorber_pml_profile_data_get
    if _newclass:
        pml_profile_data = _swig_property(_meep.absorber_pml_profile_data_get, _meep.absorber_pml_profile_data_set)

    def __init__(self):
        this = _meep.new_absorber()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_absorber
    __del__ = lambda self: None
absorber_swigregister = _meep.absorber_swigregister
absorber_swigregister(absorber)


def create_absorber_list():
    return _meep.create_absorber_list()
create_absorber_list = _meep.create_absorber_list

def destroy_absorber_list(alist):
    return _meep.destroy_absorber_list(alist)
destroy_absorber_list = _meep.destroy_absorber_list

def add_absorbing_layer(*args):
    return _meep.add_absorbing_layer(*args)
add_absorbing_layer = _meep.add_absorbing_layer

def set_dimensions(dims):
    return _meep.set_dimensions(dims)
set_dimensions = _meep.set_dimensions

def set_materials_from_geometry(*args):
    return _meep.set_materials_from_geometry(*args)
set_materials_from_geometry = _meep.set_materials_from_geometry

def make_dielectric(epsilon):
    return _meep.make_dielectric(epsilon)
make_dielectric = _meep.make_dielectric

def make_user_material(user_func, user_data):
    return _meep.make_user_material(user_func, user_data)
make_user_material = _meep.make_user_material

def make_file_material(eps_input_file):
    return _meep.make_file_material(eps_input_file)
make_file_material = _meep.make_file_material

def vec_to_vector3(pt):
    return _meep.vec_to_vector3(pt)
vec_to_vector3 = _meep.vec_to_vector3

def vector3_to_vec(v3):
    return _meep.vector3_to_vec(v3)
vector3_to_vec = _meep.vector3_to_vec

def linear_interpolate(rx, ry, rz, data, nx, ny, nz, stride):
    return _meep.linear_interpolate(rx, ry, rz, data, nx, ny, nz, stride)
linear_interpolate = _meep.linear_interpolate

def epsilon_file_material(md, p):
    return _meep.epsilon_file_material(md, p)
epsilon_file_material = _meep.epsilon_file_material

def check_offdiag(m):
    return _meep.check_offdiag(m)
check_offdiag = _meep.check_offdiag

def set_geometry_from_GDSII(*args):
    return _meep.set_geometry_from_GDSII(*args)
set_geometry_from_GDSII = _meep.set_geometry_from_GDSII

def get_GDSII_prism(*args):
    return _meep.get_GDSII_prism(*args)
get_GDSII_prism = _meep.get_GDSII_prism

def get_GDSII_volume(*args):
    return _meep.get_GDSII_volume(*args)
get_GDSII_volume = _meep.get_GDSII_volume
class vector3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector3, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _meep.vector3_x_set
    __swig_getmethods__["x"] = _meep.vector3_x_get
    if _newclass:
        x = _swig_property(_meep.vector3_x_get, _meep.vector3_x_set)
    __swig_setmethods__["y"] = _meep.vector3_y_set
    __swig_getmethods__["y"] = _meep.vector3_y_get
    if _newclass:
        y = _swig_property(_meep.vector3_y_get, _meep.vector3_y_set)
    __swig_setmethods__["z"] = _meep.vector3_z_set
    __swig_getmethods__["z"] = _meep.vector3_z_get
    if _newclass:
        z = _swig_property(_meep.vector3_z_get, _meep.vector3_z_set)

    def __init__(self):
        this = _meep.new_vector3()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_vector3
    __del__ = lambda self: None
vector3_swigregister = _meep.vector3_swigregister
vector3_swigregister(vector3)

class geom_box(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, geom_box, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, geom_box, name)
    __repr__ = _swig_repr
    __swig_setmethods__["low"] = _meep.geom_box_low_set
    __swig_getmethods__["low"] = _meep.geom_box_low_get
    if _newclass:
        low = _swig_property(_meep.geom_box_low_get, _meep.geom_box_low_set)
    __swig_setmethods__["high"] = _meep.geom_box_high_set
    __swig_getmethods__["high"] = _meep.geom_box_high_get
    if _newclass:
        high = _swig_property(_meep.geom_box_high_get, _meep.geom_box_high_set)

    def __init__(self):
        this = _meep.new_geom_box()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_geom_box
    __del__ = lambda self: None
geom_box_swigregister = _meep.geom_box_swigregister
geom_box_swigregister(geom_box)


def is_point_in_object(p, o):
    return _meep.is_point_in_object(p, o)
is_point_in_object = _meep.is_point_in_object

def is_point_in_periodic_object(p, o):
    return _meep.is_point_in_periodic_object(p, o)
is_point_in_periodic_object = _meep.is_point_in_periodic_object

def display_geometric_object_info(indentby, o):
    return _meep.display_geometric_object_info(indentby, o)
display_geometric_object_info = _meep.display_geometric_object_info

AUTOMATIC = -1
CYLINDRICAL = -2
ALL = -1
ALL_COMPONENTS = Dielectric

# MPB definitions
NO_PARITY = 0
EVEN_Z = 1
ODD_Z = 2
EVEN_Y = 4
ODD_Y = 8
TE = EVEN_Z
TM = ODD_Z
PREV_PARITY = -1

inf = 1.0e20

from .geom import (
    Block,
    Cone,
    Cylinder,
    DrudeSusceptibility,
    Ellipsoid,
    FreqRange,
    GeometricObject,
    Lattice,
    LorentzianSusceptibility,
    Matrix,
    Medium,
    NoisyDrudeSusceptibility,
    NoisyLorentzianSusceptibility,
    Prism,
    Sphere,
    Susceptibility,
    Vector3,
    Wedge,
    check_nonnegative,
    geometric_object_duplicates,
    geometric_objects_duplicates,
    geometric_objects_lattice_duplicates,
    cartesian_to_lattice,
    lattice_to_cartesian,
    lattice_to_reciprocal,
    reciprocal_to_lattice,
    cartesian_to_reciprocal,
    reciprocal_to_cartesian,
    find_root_deriv,
)
from .simulation import (
    Absorber,
    FluxRegion,
    ForceRegion,
    Harminv,
    Identity,
    Mirror,
    Near2FarRegion,
    PML,
    Rotate2,
    Rotate4,
    Simulation,
    Symmetry,
    Volume,
    after_sources,
    after_sources_and_time,
    after_time,
    at_beginning,
    at_end,
    at_every,
    at_time,
    dft_ldos,
    display_progress,
    during_sources,
    get_flux_freqs,
    get_fluxes,
    get_eigenmode_freqs,
    get_force_freqs,
    get_forces,
    get_near2far_freqs,
    get_ldos_freqs,
    in_point,
    in_volume,
    interpolate,
    output_epsilon,
    output_mu,
    output_hpwr,
    output_dpwr,
    output_tot_pwr,
    output_bfield,
    output_bfield_x,
    output_bfield_y,
    output_bfield_z,
    output_bfield_r,
    output_bfield_p,
    output_dfield,
    output_dfield_x,
    output_dfield_y,
    output_dfield_z,
    output_dfield_r,
    output_dfield_p,
    output_efield,
    output_efield_x,
    output_efield_y,
    output_efield_z,
    output_efield_r,
    output_efield_p,
    output_hfield,
    output_hfield_x,
    output_hfield_y,
    output_hfield_z,
    output_hfield_r,
    output_hfield_p,
    output_png,
    output_poynting,
    output_poynting_x,
    output_poynting_y,
    output_poynting_z,
    output_poynting_r,
    output_poynting_p,
    output_sfield,
    output_sfield_x,
    output_sfield_y,
    output_sfield_z,
    output_sfield_r,
    output_sfield_p,
    py_v3_to_vec,
    scale_flux_fields,
    scale_force_fields,
    scale_near2far_fields,
    stop_when_fields_decayed,
    synchronized_magnetic,
    to_appended,
    when_true,
    when_false,
    with_prefix
)
from .source import (
    ContinuousSource,
    CustomSource,
    EigenModeSource,
    GaussianSource,
    Source,
    SourceTime,
    check_positive,
)

if with_mpi():
    try:
        from mpi4py import MPI
    except ImportError:
        print('\n**\n** failed to load python MPI module (mpi4py)\n**\n')
        pass
    else:
# this variable reference is needed for lazy initialization of MPI
        comm = MPI.COMM_WORLD
        if am_master():
            Procs=comm.Get_size()
            (Major,Minor)=MPI.Get_version();
            print('Using MPI version {}.{}, {} processes'.format(Major, Minor, Procs));

        if not am_master():
            import os
            import sys
            saved_stdout = sys.stdout
            sys.stdout = open(os.devnull, 'w')

vacuum = Medium(epsilon=1)
air = Medium(epsilon=1)
metal = Medium(epsilon=-inf)
perfect_electric_conductor = Medium(epsilon=-inf)
perfect_magnetic_conductor = Medium(mu=-inf)
_t_start = wall_time()

def report_elapsed_time():
    print("\nElapsed run time = {:.4f} s".format(wall_time() - _t_start))

import atexit
atexit.register(report_elapsed_time)

# This file is compatible with both classic and new-style classes.


